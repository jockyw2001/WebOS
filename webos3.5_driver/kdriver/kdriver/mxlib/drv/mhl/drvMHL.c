//<MStar Software>//******************************************************************************// MStar Software// Copyright (c) 2010 - 2012 MStar Semiconductor, Inc. All rights reserved.// All software, firmware and related documentation herein ("MStar Software") are// intellectual property of MStar Semiconductor, Inc. ("MStar") and protected by// law, including, but not limited to, copyright law and international treaties.// Any use, modification, reproduction, retransmission, or republication of all// or part of MStar Software is expressly prohibited, unless prior written// permission has been granted by MStar.//// By accessing, browsing and/or using MStar Software, you acknowledge that you// have read, understood, and agree, to be bound by below terms ("Terms") and to// comply with all applicable laws and regulations://// 1. MStar shall retain any and all right, ownership and interest to MStar//    Software and any modification/derivatives thereof.//    No right, ownership, or interest to MStar Software and any//    modification/derivatives thereof is transferred to you under Terms.//// 2. You understand that MStar Software might include, incorporate or be//    supplied together with third party`s software and the use of MStar//    Software may require additional licenses from third parties.//    Therefore, you hereby agree it is your sole responsibility to separately//    obtain any and all third party right and license necessary for your use of//    such third party`s software.//// 3. MStar Software and any modification/derivatives thereof shall be deemed as//    MStar`s confidential information and you agree to keep MStar`s//    confidential information in strictest confidence and not disclose to any//    third party.//// 4. MStar Software is provided on an "AS IS" basis without warranties of any//    kind. Any warranties are hereby expressly disclaimed by MStar, including//    without limitation, any warranties of merchantability, non-infringement of//    intellectual property rights, fitness for a particular purpose, error free//    and in conformity with any international standard.  You agree to waive any//    claim against MStar for any loss, damage, cost or expense that you may//    incur related to your use of MStar Software.//    In no event shall MStar be liable for any direct, indirect, incidental or//    consequential damages, including without limitation, lost of profit or//    revenues, lost or damage of data, and unauthorized system use.//    You agree that this Section 4 shall still apply without being affected//    even if MStar Software has been modified by MStar in accordance with your//    request or instruction for your use, except otherwise agreed by both//    parties in writing.//// 5. If requested, MStar may from time to time provide technical supports or//    services in relation with MStar Software to you for your use of//    MStar Software in conjunction with your or your customer`s product//    ("Services").//    You understand and agree that, except otherwise agreed by both parties in//    writing, Services are provided on an "AS IS" basis and the warranty//    disclaimer set forth in Section 4 above shall apply.//// 6. Nothing contained herein shall be construed as by implication, estoppels//    or otherwise://    (a) conferring any license or right to use MStar name, trademark, service//        mark, symbol or any other identification;//    (b) obligating MStar or any of its affiliates to furnish any person,//        including without limitation, you and your customers, any assistance//        of any kind whatsoever, or any information; or//    (c) conferring any license or right under any intellectual property right.//// 7. These terms shall be governed by and construed in accordance with the laws//    of Taiwan, R.O.C., excluding its conflict of law rules.//    Any and all dispute arising out hereof or related hereto shall be finally//    settled by arbitration referred to the Chinese Arbitration Association,//    Taipei in accordance with the ROC Arbitration Law and the Arbitration//    Rules of the Association by three (3) arbitrators appointed in accordance//    with the said Rules.//    The place of arbitration shall be in Taipei, Taiwan and the language shall//    be English.//    The arbitration award shall be final and binding to both parties.////******************************************************************************//<MStar Software>///////////////////////////////////////////////////////////////////////////////////////////////////////// file    mdrv_mhl.c/// @author MStar Semiconductor Inc./// @brief  MHL driver Function///////////////////////////////////////////////////////////////////////////////////////////////////#ifndef _DRV_MHL_C_#define _DRV_MHL_C_//-------------------------------------------------------------------------------------------------//  Include Files//-------------------------------------------------------------------------------------------------// Common Definition#include "MsCommon.h"#include "MsVersion.h"#include "MsIRQ.h"#include "MsOS.h"#ifdef MSOS_TYPE_LINUX_KERNEL#include <linux/string.h>#else#include <string.h>#endif#include "mdrv_mhl_st.h"#include "apiMHL.h"#include "halMHL.h"#include "drvMHL.h"#include "drvSYS.h"//-------------------------------------------------------------------------------------------------//  Local Defines//-------------------------------------------------------------------------------------------------#define msg_mhl(x) x//-------------------------------------------------------------------------------------------------//  Local Structures//-------------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------------//  Global Variables//-------------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------------//  Local Variables//-------------------------------------------------------------------------------------------------static MS_U8 MhlDevCap_tbl[MHL_DEVICE_CAPABILITY_SIZE +MHL_XDEVICE_CAPABILITY_SIZE] ={    0x00, // MHL_DEV_STATE_0x00    0x12, // MHL_VERSION_0x01    0x11,    // MHL_DEV_CAT_0x02, [4]:POW, [3:0]:DEV_TYPE    (DMHL_ADOPTER_ID>>8), // MHL_ADOPTER_ID_H_0x03    (DMHL_ADOPTER_ID&0xFF), // MHL_ADOPTER_ID_L_0x04#if DMHL_CTS // not support packed-pixel mode    0x37, // MHL_VID_LINK_MODE_0x05, [5]:SUPP_VGA, [4]:ISLANDS, [3]:PPIXEL, [2]:YUV422, [1]:YUV444, [0]:RGB444#else    0x3F, // MHL_VID_LINK_MODE_0x05, [5]:SUPP_VGA, [4]:ISLANDS, [3]:PPIXEL, [2]:YUV422, [1]:YUV444, [0]:RGB444#endif    0x01, // MHL_AUD_LINK_MODE_0x06, [1]:AUD_8CH, [0]:AUD_2CH    0x00, // MHL_VIDEO_TYPE_0x07, [7]: SUPP_VT, [3]:GAME, [2]:CINEMA, [1]: PHOTO, [0]:GRAPHICS    0x01, // MHL_LOG_DEV_MAP_0x08, [0]:LD_DISPLAY    0x0F, // MHL_BANDWIDTH_0x09, 15*5MHz = 75MHz    0x07, // MHL_FEATURE_FLAG_0x0A, [2]:Scratchpad, [1]:RAP, [0]:RCP    (DMHL_DEVICE_ID>>8), // MHL_DEVICE_ID_H_0x0B, ? CHIP_ID    (DMHL_DEVICE_ID&0xFF), // MHL_DEVICE_ID_L_0x0C, ? CHIP_ID    MHL_MSC_SCRATCHPAD_SIZE, // MHL_SCRATCHPAD_SIZE_0x0D, 16 bytes    0x33, // MHL_INT_STAT_0x0E, [7:4]:Status 4 bytes, [3:0]:Interrupt 4 bytes    0x00, // MHL_RESERVED_0x0F    0x00, // MHL_ECBUS_SPEEDS_0x80    0x00, // MHL_TMDS_SPEEDS_0x81    0x00, // MHL_ECBUS_DEV_ROLES_0x82    0x00, // MHL_LOG_DEV_MAPX_0x83};MS_U8 tMHL_HEV_VIC_TABLE[] ={    MHL_HEV_VIC_INDEX0,    MHL_HEV_VIC_INDEX1,    MHL_HEV_VIC_INDEX2,    MHL_HEV_VIC_INDEX3,    MHL_HEV_VIC_INDEX4,    MHL_HEV_VIC_INDEX5,};MS_U32 tMHL_AUDIO_TUNNEL_TABLE[] ={    MHL_AUDIO_TUNNEL_INDEX0,    MHL_AUDIO_TUNNEL_INDEX1,    MHL_AUDIO_TUNNEL_INDEX2,    MHL_AUDIO_TUNNEL_INDEX3,    MHL_AUDIO_TUNNEL_INDEX4,    MHL_AUDIO_TUNNEL_INDEX5,};MS_U16 tMHL_EMSC_SUPPORT_TABLE[] ={    MHL_EMSC_SUPPORT_BURST_ID0,    MHL_EMSC_SUPPORT_BURST_ID1,    MHL_EMSC_SUPPORT_BURST_ID2,    MHL_EMSC_SUPPORT_BURST_ID3,    MHL_EMSC_SUPPORT_BURST_ID4,    MHL_EMSC_SUPPORT_BURST_ID5,};static MS_U8 ucMHLVenderID = DMHL_VENDOR_ID;MS_U8 ucMHLCbusSelect = MHL_CBUS_SELECT_PORT_INITIAL;MS_U8 ucMHLClockMode = CBUS_CLOCK_NORMAL_24BIT;MS_U8 ucMHLCableDetect = 0;MS_U8 ucMHLWriteBurstSequence = 0;MS_U8 ucMHL3DTotalEntryDTD = 0;MS_U8 ucMHL3DTotalEntryVIC = 0;MS_U8 ucMHL3DInformationDTD[MHL_3D_DTD_INFORMATION_LENGTH];MS_U8 ucMHL3DInformationVIC[MHL_3D_VIC_INFORMATION_LENGTH];MS_U8 ucMHLFunctionCapability = 0;MS_U8 ucMHLECbusState = 0;MS_U8 ucMHLECbusStatusIndex = 0;MS_U8 ucMHLBISTReadyIndex = 0;ST_VIRTUAL_CHANNEL_INFO stVirtualChannelInfo[MHL_VIRTUAL_CHANNEL_LENGTH];ST_BIST_MODE_INFO stBISTParameterInfo;//-------------------------------------------------------------------------------------------------//  Local Functions//-------------------------------------------------------------------------------------------------//**************************************************************************//  [Function Name]://                  mdrv_mhl_CbusSetPacket(BYTE ucHeader, Bool bControl, BYTE ucContent)//  [Description]//                  MHL Cbus Packet setting//  [Arguments]://                  ucHeader: Packet header type//                  bControl: Packet control bit type//                  ucContent: Packet payload//  [Return]://                  Packet word for register write//**************************************************************************MS_U16 _mdrv_mhl_CbusSetPacket(MS_U8 ucHeader, MS_BOOL bControl, MS_U8 ucContent){    MS_BOOL bParity = 0;    MS_U16 usPacket = (ucHeader <<9) |(bControl <<8) |ucContent;    do    {        bParity ^= (usPacket & BIT(0));        usPacket = usPacket >>1;    }    while(usPacket);    usPacket = (bParity <<11) |(ucHeader <<9) |(bControl <<8) |ucContent;    return (usPacket |BIT(15));}//**************************************************************************//  [Function Name]://                  _mdrv_mhl_GetCableDetectPort//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL _mdrv_mhl_GetCableDetectPort(MS_U8 ucPort){    return GET_MHL_CABLE_DETECT_PORT(mhal_mhl_GetCbusSelect(ucPort));}//**************************************************************************//  [Function Name]://                  _mdrv_mhl_SearchNextCbusSelect//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_U8 _mdrv_mhl_SearchNextCbusSelect(MS_U8 ucCbusSelect){    MS_U8 uctemp = ucCbusSelect +1;    for(; uctemp <(ucCbusSelect +MHL_CBUS_SELECT_MASK); uctemp++)    {        if(GET_MHL_CABLE_DETECT_PORT(uctemp %MHL_CBUS_SELECT_MASK))        {            ucCbusSelect = uctemp %MHL_CBUS_SELECT_MASK;            break;        }    }        return ucCbusSelect;}//**************************************************************************//  [Function Name]://                  _mdrv_mhl_WriteBurstCheckSum()//  [Description]//                  //  [Arguments]://                  //  [Return]:////**************************************************************************MS_U8 _mdrv_mhl_WriteBurstCheckSum(MS_U8 *pData){    MS_U8 uctemp = 0;    MS_U8 ucCheckSum = 0;    for(uctemp = 0; uctemp <MHL_MSC_SCRATCHPAD_SIZE; uctemp++)    {        ucCheckSum = ucCheckSum +pData[uctemp];    }    ucCheckSum = (ucCheckSum ^0xFF) +1;    return ucCheckSum;}//**************************************************************************//  [Function Name]://                  _mdrv_mhl_DTDPresentinEDID()//  [Description]//                  //  [Arguments]://                  //  [Return]:////**************************************************************************MS_BOOL _mdrv_mhl_DTDPresentinEDID(MS_U8 *pData){    MS_BOOL bPresent = FALSE;    MS_U8 uctemp = 0;    for(uctemp = 0; uctemp < 3; uctemp++)    {        if(pData[uctemp] > 0)        {            bPresent = TRUE;            break;        }    }    return bPresent;}//**************************************************************************//  [Function Name]://                  _mdrv_mhl_GetDTD3DTimingInformation()//  [Description]//                  //  [Arguments]://                  //  [Return]:////**************************************************************************MS_U8 _mdrv_mhl_GetDTD3DTimingInformation(MS_U8 *pData){    MS_BOOL bInterlace = ((pData[17] &BIT(7)) ?TRUE :FALSE);    MS_U8 ucIndex = 0;    MS_U16 usHActive = ((pData[4] &BMASK(7:4)) <<4) |pData[2];    MS_U16 usHBlank = ((pData[4] &BMASK(3:0)) <<8) |pData[3];    MS_U16 usVActive = ((pData[7] &BMASK(7:4)) <<4) |pData[5];    MS_U16 usVBlank = ((pData[7] &BMASK(3:0)) <<8) |pData[6];    MS_U16 usHTotal = usHActive +usHBlank;    MS_U16 usVTotal = usVActive +usVBlank;    MS_U16 usPixelClk = (pData[1] <<8) |pData[0];    MS_U32 ulFrequenct = (usPixelClk *100 /usHTotal) *1000 /usVTotal;    usPixelClk = ulFrequenct;        //msg_mhl(printf("** MHL get DTD timing %d x %d @ %d\r\n", usHActive, usVActive, usPixelClk));        if((usHActive == 1920) && (usVActive == 1080)) // 1920x1080p    {        if((ulFrequenct > 230) && (ulFrequenct < 245)) // 24Hz         {            ucIndex = MHL_3D_PRESENT_VIC_1920x1080p24Hz;        }    }    else if((usHActive == 1920) && (usVActive == 540) && bInterlace) // 1920x1080i    {        if((ulFrequenct > 590) && (ulFrequenct < 610)) // 60Hz        {            ucIndex = MHL_3D_PRESENT_VIC_1920x1080i60Hz;        }        else if((ulFrequenct > 490) && (ulFrequenct < 510)) // 50Hz        {            ucIndex = MHL_3D_PRESENT_VIC_1920x1080i50Hz;        }    }    else if((usHActive == 1280) && (usVActive == 720)) // 1280x720p    {        if((ulFrequenct > 590) && (ulFrequenct < 610)) // 60Hz        {            ucIndex = MHL_3D_PRESENT_VIC_1280x720p60Hz;        }        else if((ulFrequenct > 490) && (ulFrequenct < 510)) // 50Hz        {            ucIndex = MHL_3D_PRESENT_VIC_1280x720p50Hz;        }    }        return ucIndex;}//**************************************************************************//  [Function Name]://                  _mdrv_mhl_InsertDTD3DInformation()//  [Description]//                  //  [Arguments]://                  //  [Return]:////**************************************************************************MS_U8 _mdrv_mhl_InsertDTD3DInformation(MS_U8 ucIndex, MS_U8 ucData){    MS_U8 uctemp = 0;    ucData = ((ucData &BMASK(6:5)) >> 4) |(ucData &BIT(0));        switch(ucData)    {        case MHL_3D_DTD_STEREO_FIELD_SEQUENTIAL_RIGHT:            uctemp = MASKSET(uctemp, MHL_3D_FS_SUPPORT, MHL_3D_SUPPORT_MASK);            break;        case MHL_3D_DTD_STEREO_FIELD_SEQUENTIAL_LEFT:            uctemp = MASKSET(uctemp, MHL_3D_FS_SUPPORT, MHL_3D_SUPPORT_MASK);            break;        case MHL_3D_DTD_STEREO_2WAY_INTERLEAVED_RIGHT:            // No setting            break;        case MHL_3D_DTD_STEREO_2WAY_INTERLEAVED_LEFT:            // No setting            break;        case MHL_3D_DTD_STEREO_4WAY_INTERLEAVED:            // No setting            break;        case MHL_3D_DTD_STEREO_SIDE_BY_SIDE_INTERLEAVED:            uctemp = MASKSET(uctemp, MHL_3D_LR_SUPPORT, MHL_3D_SUPPORT_MASK);            break;        default: // MHL_3D_DTD_STEREO_NORMAL_DISPLAY                        break;    };    SET_MHL_3D_DTD_INFORMATION(ucIndex, uctemp);        for(uctemp = 0, ucData = 0; uctemp < (ucIndex +1); uctemp++)    {        if(GET_MHL_3D_DTD_INFORMATION(uctemp) > 0)        {            ucData = uctemp +1;        }    }    return ucData;}//**************************************************************************//  [Function Name]://                  _mdrv_mhl_CheckVIC3DStructureAll()//  [Description]//                  //  [Arguments]://                  //  [Return]:////**************************************************************************MS_U8 _mdrv_mhl_CheckVIC3DStructureAll(MS_U16 usData){    MS_U8 uctemp = 0;    if((usData &BIT(0)) == BIT(0)) // Support frame packing 3D formats    {        uctemp = MASKSET(uctemp, MHL_3D_FS_SUPPORT, MHL_3D_FS_SUPPORT);    }    if((usData &BIT(6)) == BIT(6)) // Support top and bottom 3D formats    {        uctemp = MASKSET(uctemp, MHL_3D_TB_SUPPORT, MHL_3D_TB_SUPPORT);    }    if((usData &BIT(8)) == BIT(8)) // Support side by side 3D formats    {        uctemp = MASKSET(uctemp, MHL_3D_LR_SUPPORT, MHL_3D_LR_SUPPORT);    }    return uctemp;}//**************************************************************************//  [Function Name]://                  _mdrv_mhl_CheckVIC3DStructure()//  [Description]//                  //  [Arguments]://                  //  [Return]:////**************************************************************************MS_U8 _mdrv_mhl_CheckVIC3DStructure(MS_U8 ucData){    MS_U8 uctemp = 0;    if(ucData == 0) // Support frame packing    {        uctemp = MASKSET(uctemp, MHL_3D_FS_SUPPORT, MHL_3D_FS_SUPPORT);    }    else if(ucData == 6) // Support top and bottom    {        uctemp = MASKSET(uctemp, MHL_3D_TB_SUPPORT, MHL_3D_TB_SUPPORT);    }    else if(ucData == 8) // Support side by side    {        uctemp = MASKSET(uctemp, MHL_3D_LR_SUPPORT, MHL_3D_LR_SUPPORT);    }    return uctemp;}//**************************************************************************//  [Function Name]://                  _mdrv_mhl_ParsingVIC3DInformation()//  [Description]//                  //  [Arguments]://                  //  [Return]:////**************************************************************************MS_BOOL _mdrv_mhl_ParsingVIC3DInformation(MS_U8 ucExtendLength, MS_U8 *pData){    MS_BOOL bVICParseFinish = TRUE;    MS_BOOL b3DPresent = FALSE;    MS_U8 uctemp = 0;    MS_U8 ucIndex = 0;    MS_U8 ucValue = 0;    MS_U8 ucLength = 0;    MS_U8 ucVSDBAddr = 0;    MS_U8 ucVSDBLength = 0;    MS_U8 uc3DMultiPresent = 0;    MS_U8 ucVICTimingNum = 0;    MS_U8 ucVICTiming[MHL_3D_VIC_INFORMATION_LENGTH];    MS_U16 usMaskValue = 0;    for(uctemp = 0; uctemp < MHL_3D_VIC_INFORMATION_LENGTH; uctemp++)    {        ucVICTiming[uctemp] = 0;                SET_MHL_3D_VIC_INFORMATION(uctemp, 0);    }        for(uctemp = 0; uctemp < ucExtendLength; uctemp++)    {        ucValue = (pData[uctemp] &BMASK(7:5)) >>5;        ucLength = pData[uctemp] &BMASK(4:0);                switch(ucValue)        {            case MHL_EDID_AUDIO_DATA_BLOCK_CODE:                msg_mhl(printf("** MHL get audio data block length %d in port %c\r\n", ucLength, MHL_INPUT_PORT(GET_MHL_CBUS_SELECT_PATH())));                break;            case MHL_EDID_VIDEO_DATA_BLOCK_CODE:                msg_mhl(printf("** MHL get video data block length %d in port %c\r\n", ucLength, MHL_INPUT_PORT(GET_MHL_CBUS_SELECT_PATH())));                if(ucLength > MHL_3D_VIC_INFORMATION_LENGTH)                {                    ucVICTimingNum = MHL_3D_VIC_INFORMATION_LENGTH;                }                else                {                    ucVICTimingNum = ucLength;                }                                for(ucIndex = 0; ucIndex <ucVICTimingNum; ucIndex++)                {                    ucVICTiming[ucIndex] = pData[uctemp +ucIndex +1];                }                                break;            case MHL_EDID_VENDER_SPECIFIC_DATA_BLOCK_CODE:                msg_mhl(printf("** MHL get vender specific data block length %d in port %c\r\n", ucLength, MHL_INPUT_PORT(GET_MHL_CBUS_SELECT_PATH())));                ucVSDBAddr = uctemp;                bVICParseFinish = FALSE;                                break;            case MHL_EDID_SPEAKER_ALLOCATION_DATA_BLOCK_CODE:                msg_mhl(printf("** MHL get speaker allocation data block length %d in port %c\r\n", ucLength, MHL_INPUT_PORT(GET_MHL_CBUS_SELECT_PATH())));                break;            case MHL_EDID_VESA_DTC_DATA_BLOCK_CODE:                msg_mhl(printf("** MHL get VESA DTC data block length %d in port %c\r\n", ucLength, MHL_INPUT_PORT(GET_MHL_CBUS_SELECT_PATH())));                break;            case MHL_EDID_USE_EXTENDED_TAG_BLOCK_CODE:                msg_mhl(printf("** MHL get use extended tag length %d in port %c\r\n", ucLength, MHL_INPUT_PORT(GET_MHL_CBUS_SELECT_PATH())));                break;            default:                                break;        };        uctemp = uctemp +ucLength;    }    ucIndex = MHL_VIC_PARSING_START;    ucVSDBLength = ucVSDBAddr +1;        while(!bVICParseFinish)    {        ucValue = pData[ucVSDBAddr];        if(ucVSDBAddr > ucVSDBLength) // Check total length        {            ucIndex = MHL_VIC_PARSING_FINISH;        }                switch(ucIndex)        {            case MHL_VIC_PARSING_START:                ucVSDBLength = pData[ucVSDBAddr] &BMASK(4:0);                                if(ucVSDBLength < 8) // HDMI_Video_Present absent, no 3D information                {                    ucIndex = MHL_VIC_PARSING_FINISH;                }                else                {                    ucVSDBAddr = ucVSDBAddr +8;                    ucIndex = MHL_VIC_PARSING_CHECK_HDMI_VIDEO_PRESENT;                }                ucVSDBLength = ucVSDBAddr +ucVSDBLength;                                break;            case MHL_VIC_PARSING_CHECK_HDMI_VIDEO_PRESENT:                if((ucValue &BIT(5)) != BIT(5)) // HDMI_Video_Present absent, no 3D information                {                    ucIndex = MHL_VIC_PARSING_FINISH;                }                else                {                    ucIndex = MHL_VIC_PARSING_CHECK_3D_PRESENT;                                        if((ucValue &BIT(7)) != BIT(7)) // Latency_Fields_Present absent, no video and audio latency and no interlaced video and audio latency                    {                        ucVSDBAddr++;                    }                    else                    {                        if((ucValue &BIT(6)) != BIT(6)) // I_Latency_Fields_Present absent, no video and audio latency                        {                            ucVSDBAddr = ucVSDBAddr +3;                        }                        else                        {                            ucVSDBAddr = ucVSDBAddr +5;                        }                    }                }                                break;            case MHL_VIC_PARSING_CHECK_3D_PRESENT:                if((ucValue &BIT(7)) != BIT(7)) // 3D_Present absent, no 3D information                {                    ucIndex = MHL_VIC_PARSING_FINISH;                }                else                {                    b3DPresent = TRUE;                    uc3DMultiPresent = (ucValue &BMASK(6:5)) >> 5;                    if(uc3DMultiPresent == 0)                    {                        ucIndex = MHL_VIC_PARSING_3D_MULTI_PRESENT_00;                    }                    else if(uc3DMultiPresent == 3) // Reserved for future use                    {                        ucIndex = MHL_VIC_PARSING_FINISH;                    }                    else                    {                        ucIndex = MHL_VIC_PARSING_CHECK_HDMI_VIC;                        ucVSDBAddr++;                    }                }                                break;            case MHL_VIC_PARSING_CHECK_HDMI_VIC:                ucLength = (ucValue &BMASK(7:5)) >> 5;                ucVSDBAddr = ucVSDBAddr +ucLength +1;                                if(uc3DMultiPresent == 1)                {                    ucIndex = MHL_VIC_PARSING_3D_MULTI_PRESENT_01;                }                else // uc3DMultiPresent = 2                {                    ucIndex = MHL_VIC_PARSING_3D_MULTI_PRESENT_10;                }                ucLength = ucVSDBAddr +(ucValue &BMASK(4:0)) -1; // HDMI_3D_LEN                                break;            case MHL_VIC_PARSING_3D_MULTI_PRESENT_00:                ucIndex = MHL_VIC_PARSING_CHECK_3D_PRESENT_TIMING;                                break;            case MHL_VIC_PARSING_3D_MULTI_PRESENT_01:                ucValue = _mdrv_mhl_CheckVIC3DStructureAll((pData[ucVSDBAddr +1] |(pData[ucVSDBAddr] << 8)));                for(uctemp = 0; uctemp <ucVICTimingNum; uctemp++)                {                    SET_MHL_3D_VIC_INFORMATION(uctemp, ucValue);                }                                ucIndex = MHL_VIC_PARSING_CHECK_3D_PRESENT_TIMING;                                break;            case MHL_VIC_PARSING_3D_MULTI_PRESENT_10:                ucValue = _mdrv_mhl_CheckVIC3DStructureAll((pData[ucVSDBAddr +1] |(pData[ucVSDBAddr] << 8)));                usMaskValue = pData[ucVSDBAddr +3] |(pData[ucVSDBAddr +2] << 8);                for(uctemp = 0; uctemp <ucVICTimingNum; uctemp++)                {                    if((usMaskValue &BIT(uctemp)) == BIT(uctemp))                    {                        SET_MHL_3D_VIC_INFORMATION(uctemp, ucValue);                    }                }                ucVSDBAddr = ucVSDBAddr +4;                                ucIndex = MHL_VIC_PARSING_CHECK_3D_STRUCTURE;                                break;            case MHL_VIC_PARSING_CHECK_3D_STRUCTURE:                if(ucVSDBAddr > ucLength) // No 3D sturcture                {                    ucIndex = MHL_VIC_PARSING_CHECK_3D_PRESENT_TIMING;                }                else                {                    uctemp = (ucValue &BMASK(7:4)) >> 4;                    ucValue = ucValue &BMASK(3:0);                    SET_MHL_3D_VIC_INFORMATION(uctemp, _mdrv_mhl_CheckVIC3DStructure(ucValue));                                        if(ucValue < 8) // Only 2D_VIC_Order and 3D_Structure, 1 byte                    {                        ucVSDBAddr++;                    }                    else // Add 3D_Detail, 2 byte                    {                        ucVSDBAddr = ucVSDBAddr +2;                    }                }                                break;                            case MHL_VIC_PARSING_CHECK_3D_PRESENT_TIMING:                for(uctemp = 0; uctemp <ucVICTimingNum; uctemp++)                {                    ucValue = GET_MHL_3D_VIC_INFORMATION(uctemp);                    switch(ucVICTiming[uctemp])                    {                        case MHL_3D_PRESENT_VIC_1920x1080p24Hz: // Support frame packing with top and bottom                        case MHL_3D_PRESENT_VIC_1280x720p60Hz: // Support frame packing with top and bottom                        case MHL_3D_PRESENT_VIC_1280x720p50Hz: // Support frame packing with top and bottom                            ucValue = MASKSET(ucValue, (MHL_3D_FS_SUPPORT |MHL_3D_TB_SUPPORT), (MHL_3D_FS_SUPPORT |MHL_3D_TB_SUPPORT));                            SET_MHL_3D_VIC_INFORMATION(uctemp, ucValue);                                                        break;                        case MHL_3D_PRESENT_VIC_1920x1080i60Hz: // Support side by side                        case MHL_3D_PRESENT_VIC_1920x1080i50Hz: // Support side by side                            ucValue = MASKSET(ucValue, MHL_3D_LR_SUPPORT, MHL_3D_LR_SUPPORT);                            SET_MHL_3D_VIC_INFORMATION(uctemp, ucValue);                                                        break;                                                    default:                                                        break;                    };                }                                ucIndex = MHL_VIC_PARSING_FINISH;                                break;                                case MHL_VIC_PARSING_FINISH:                bVICParseFinish = TRUE;                                break;                            default:                                break;        };    }    for(uctemp = 0, ucValue = 0; uctemp < MHL_3D_VIC_INFORMATION_LENGTH; uctemp++)    {        if(GET_MHL_3D_VIC_INFORMATION(uctemp) > 0)        {            ucValue = uctemp +1;        }    }    SET_MHL_3D_TOT_ENT_VIC(ucValue);        return b3DPresent;}//**************************************************************************//  [Function Name]://                  _mdrv_mhl_InsertVCInformation()//  [Description]:////  [Arguments]:////  [Return]:////**************************************************************************void _mdrv_mhl_InsertVCInformation(MS_BOOL bReceiveVC, MS_U8 ucVCNumber, MS_U8 ucVCFeatureID, MS_U8 ucVCSlotSize){    MS_BOOL bFindVC = FALSE;    MS_U8 uctemp = 0;    MS_U8 ucTargetVC = MHL_VIRTUAL_CHANNEL_LENGTH;    MS_U8 ucTotalTimeSlot = 0;    MS_U8 ucResponseCode = MHL_VC_RESPONSE_ACCEPT;    ST_VIRTUAL_CHANNEL_INFO *ucMHLVCInformation = &GET_MHL_VC_INFORMATION(0);    if(ucVCFeatureID >= MHL_VC_FEATURE_ID_END) // Invalid feature ID    {        ucResponseCode = MHL_VC_RESPONSE_REJECT_FEATURE_ID;    }    else if((ucVCFeatureID == MHL_VC_FEATURE_ID_EMSC) && (ucVCSlotSize != MHL_EMSC_TIME_SLOT_DEFAULT))    {        ucResponseCode = MHL_VC_RESPONSE_REJECT_CHANNEL_SIZE;    }    for(uctemp = 0; uctemp <MHL_VIRTUAL_CHANNEL_LENGTH; uctemp++)    {        if(!bFindVC)        {            if(ucMHLVCInformation[uctemp].ucVCNumber == ucVCNumber) // VC present, information change            {                ucTargetVC = uctemp;                bFindVC = TRUE;            }            else if(ucMHLVCInformation[uctemp].ucVCNumber == 0) // VC absent, insert new information            {                ucTargetVC = uctemp;                ucMHLVCInformation[ucTargetVC].ucVCNumber = ucVCNumber;                ucMHLVCInformation[ucTargetVC].ucVCFeatureID = ucVCFeatureID;                break;            }        }        ucTotalTimeSlot = ucTotalTimeSlot +ucMHLVCInformation[uctemp].ucVCSlotSize;    }    if(ucTargetVC < MHL_VIRTUAL_CHANNEL_LENGTH) // Can insert new VC information    {        ucMHLVCInformation[ucTargetVC].bVCConfirm = TRUE;        if(ucMHLVCInformation[ucTargetVC].ucVCFeatureID != ucVCFeatureID) // Same VC number, but different feature ID        {            ucResponseCode = MHL_VC_RESPONSE_REJECT_NUMBER;        }        else if(ucTotalTimeSlot +ucVCSlotSize > MHL_ECBUS_S_TIME_SLOT_TOTAL -1) // Time slot not enough        {            ucResponseCode = MHL_VC_RESPONSE_REJECT_CHANNEL_SIZE;        }        else        {            if(bFindVC)            {                ucMHLVCInformation[ucTargetVC].ucVCResponseCode = ucMHLVCInformation[ucTargetVC].ucVCSlotSize;            }            ucMHLVCInformation[ucTargetVC].ucVCSlotSize = ucVCSlotSize;        }        if(bReceiveVC)        {            ucMHLVCInformation[ucTargetVC].ucVCResponseCode = ucResponseCode;        }    }    else // Virtual channel length is too small    {        msg_mhl(printf("** MHL virtual channel length too small port %c\r\n", MHL_INPUT_PORT(GET_MHL_CBUS_SELECT_PATH())));    }}//**************************************************************************//  [Function Name]://                  _mdrv_mhl_CheckVCInformation()//  [Description]:////  [Arguments]:////  [Return]:////**************************************************************************void _mdrv_mhl_CheckVCInformation(MS_U8 ucVCNumber, MS_U8 ucVCFeatureID, MS_U8 ucResponseCode){    MS_U8 uctemp = 0;    MS_U8 ucTargetVC = MHL_VIRTUAL_CHANNEL_LENGTH;    ST_VIRTUAL_CHANNEL_INFO *ucMHLVCInformation = &GET_MHL_VC_INFORMATION(0);    for(uctemp = 0; uctemp <MHL_VIRTUAL_CHANNEL_LENGTH; uctemp++)    {        if(ucMHLVCInformation[uctemp].ucVCNumber == ucVCNumber) // VC present, information change        {            ucTargetVC = uctemp;            if(ucMHLVCInformation[uctemp].ucVCFeatureID != ucVCFeatureID)            {            }            break;        }    }    if(ucTargetVC < MHL_VIRTUAL_CHANNEL_LENGTH) // Can insert new VC information    {        if(ucResponseCode == MHL_VC_RESPONSE_REJECT_CHANNEL_SIZE)        {            ucMHLVCInformation[ucTargetVC].ucVCSlotSize = ucMHLVCInformation[ucTargetVC].ucVCResponseCode;        }        else if(ucResponseCode == MHL_VC_RESPONSE_REJECT_NUMBER)        {            ucMHLVCInformation[ucTargetVC].ucVCSlotSize = 0;        }        else if(ucResponseCode == MHL_VC_RESPONSE_REJECT_FEATURE_ID)        {            ucMHLVCInformation[ucTargetVC].ucVCSlotSize = 0;        }        ucMHLVCInformation[ucTargetVC].ucVCResponseCode = MHL_VC_RESPONSE_ACCEPT;    }}//**************************************************************************//  [Function Name]://                  _mdrv_mhl_SlotAllocationAlgorithm()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void _mdrv_mhl_SlotAllocationAlgorithm(MS_U8 ucChannelIndex, MS_U8 ucNValue, MS_U8 ucMValue, MS_U8 *pSlotAllocation){    MS_U8 uctemp = 0;    MS_U8 ucCounter = 0;    for(uctemp = 0; uctemp <MHL_ECBUS_S_TIME_SLOT_TOTAL; uctemp++)    {        if(pSlotAllocation[uctemp] == MHL_CBUS_SLOT_NOT_ALLOCATE)        {            if(ucCounter >= ucNValue)            {                pSlotAllocation[uctemp] = ucChannelIndex;            }            ucCounter = (ucCounter +ucNValue) %(ucNValue +ucMValue);        }    }}//**************************************************************************//  [Function Name]://                  _mdrv_mhl_eCbusTimeSlotAllocation()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void _mdrv_mhl_eCbusTimeSlotAllocation(void){    MS_U8 uctemp = 0;    MS_U8 ucTimeSlotNumber = MHL_ECBUS_S_TIME_SLOT_TOTAL -1;    MS_U8 ucSlotAllocation[MHL_ECBUS_S_TIME_SLOT_TOTAL];    MS_U8 ucVirtualChannel[MHL_VIRTUAL_CHANNEL_LENGTH +2];    ST_VIRTUAL_CHANNEL_INFO *ucMHLVCInformation = &GET_MHL_VC_INFORMATION(0);    for(uctemp = 0; uctemp <(MHL_VIRTUAL_CHANNEL_LENGTH +2); uctemp++)    {        ucVirtualChannel[uctemp] = 0;    }    for(uctemp = 0; uctemp <MHL_ECBUS_S_TIME_SLOT_TOTAL; uctemp++)    {        if(uctemp == 0)        {            ucSlotAllocation[uctemp] = 0;        }        else        {            ucSlotAllocation[uctemp] = MHL_CBUS_SLOT_NOT_ALLOCATE;        }    }    ucVirtualChannel[0] = MHL_CBUS1_TIME_SLOT_DEFAULT;    for(uctemp = 0; uctemp <MHL_VIRTUAL_CHANNEL_LENGTH; uctemp++)    {        if(ucMHLVCInformation[uctemp].ucVCSlotSize == 0)        {            break;        }        else        {            ucVirtualChannel[uctemp +1] = ucMHLVCInformation[uctemp].ucVCSlotSize;            ucTimeSlotNumber = ucTimeSlotNumber -ucMHLVCInformation[uctemp].ucVCSlotSize;        }    }    ucVirtualChannel[uctemp +1] = ucTimeSlotNumber;    for(uctemp = 0; uctemp <(MHL_VIRTUAL_CHANNEL_LENGTH +2); uctemp++)    {        msg_mhl(printf("** MHL time slot assign %d\r\n", ucVirtualChannel[uctemp]));    }    ucTimeSlotNumber = MHL_ECBUS_S_TIME_SLOT_TOTAL -1;    for(uctemp = MHL_VIRTUAL_CHANNEL_LENGTH +1; ucTimeSlotNumber > 0; uctemp--)    {        if(ucVirtualChannel[uctemp] > 0)        {            ucTimeSlotNumber = ucTimeSlotNumber -ucVirtualChannel[uctemp];            _mdrv_mhl_SlotAllocationAlgorithm(uctemp, ucTimeSlotNumber, ucVirtualChannel[uctemp], ucSlotAllocation);        }    }    for(uctemp = 0; uctemp <MHL_ECBUS_S_TIME_SLOT_TOTAL; uctemp++)    {        msg_mhl(printf("** MHL time slot allocation %d\r\n", ucSlotAllocation[uctemp]));    }}//**************************************************************************//  [Function Name]://                  _mdrv_mhl_SortingVCInformation()//  [Description]:////  [Arguments]:////  [Return]:////**************************************************************************void _mdrv_mhl_SortingVCInformation(MS_BOOL bClearFlag){    MS_U8 uctemp = 0;    MS_U8 ucIndex = 0;    MS_U8 ucTargetVC = MHL_VIRTUAL_CHANNEL_LENGTH;    ST_VIRTUAL_CHANNEL_INFO stVirtualChannelTemp = {FALSE, 0, 0, 0, 0};    ST_VIRTUAL_CHANNEL_INFO *ucMHLVCInformation = &GET_MHL_VC_INFORMATION(0);    for(ucIndex = 0; ucIndex <(ucTargetVC -1); ucIndex++)    {        for(uctemp = 0; uctemp <(ucTargetVC -ucIndex -1); uctemp++)        {            if(ucMHLVCInformation[uctemp +1].ucVCNumber == 0)            {                ucTargetVC = uctemp +1;                break;            }            else            {                if(ucMHLVCInformation[uctemp].ucVCSlotSize == 0)                {                    ucMHLVCInformation[uctemp].ucVCNumber = 0xFF;                }                if(ucMHLVCInformation[uctemp +1].ucVCNumber < ucMHLVCInformation[uctemp].ucVCNumber)                {                    memcpy(&stVirtualChannelTemp, &ucMHLVCInformation[uctemp +1], sizeof(ST_VIRTUAL_CHANNEL_INFO));                    memcpy(&ucMHLVCInformation[uctemp +1], &ucMHLVCInformation[uctemp], sizeof(ST_VIRTUAL_CHANNEL_INFO));                    memcpy(&ucMHLVCInformation[uctemp], &stVirtualChannelTemp, sizeof(ST_VIRTUAL_CHANNEL_INFO));                }            }        }    }    for(uctemp = 0; uctemp <MHL_VIRTUAL_CHANNEL_LENGTH; uctemp++)    {        if(ucMHLVCInformation[uctemp].ucVCSlotSize == 0)        {            ucMHLVCInformation[uctemp].ucVCNumber = 0;        }        if(bClearFlag)        {            ucMHLVCInformation[uctemp].bVCConfirm = FALSE;        }        msg_mhl(printf("** MHL VC sorting number %d\r\n", ucMHLVCInformation[uctemp].ucVCNumber));        msg_mhl(printf("** MHL VC sorting slot %d\r\n", ucMHLVCInformation[uctemp].ucVCSlotSize));    }}//**************************************************************************//  [Function Name]://                  _mdrv_mhl_ECbusStatusClear()//  [Description]:////  [Arguments]:////  [Return]:////**************************************************************************void _mdrv_mhl_ECbusStatusClear(void){    CLR_MHL_ECBUS_STATE();    CLR_MHL_CBUS_TX_QUEUE_FREEZE();}//-------------------------------------------------------------------------------------------------//  Global Functions//-------------------------------------------------------------------------------------------------//**************************************************************************//  [Function Name]://                  mdrv_mhl_MHLSupportPath()//  [Description]//                  MHL support path//  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_MHLSupportPath(MS_U8 ucSelect){    MS_BOOL bMHLEfuseFlag = TRUE;    MS_U8 uctemp = 0;        mhal_mhl_MHLSupportPath(ucSelect);    bMHLEfuseFlag = MDrv_SYS_Query(E_SYS_QUERY_MHL_SUPPORTED);    //mhal_mhl_InsertChipIDforCheck(MDrv_SYS_GetChipID());    if(mhal_mhl_CheckEfuseControlFlag(bMHLEfuseFlag))    {        msg_mhl(printf("** MHL function not support in this chip ###\r\n"));    }    else    {        for(uctemp = 0; uctemp < MHL_CBUS_SELECT_MASK ;uctemp++)        {            if(ucSelect &BIT(uctemp))            {                msg_mhl(printf("** MHL function support in port %c\r\n", MHL_INPUT_PORT(uctemp)));            }        }    }}//**************************************************************************//  [Function Name]://                  mdrv_mhl_initial()//  [Description]//                  MHL init//  [Arguments]://                  *edid: MHL EDID data//                  *devcap: MHL device capability//  [Return]:////**************************************************************************void mdrv_mhl_initial(MS_U8 *edid, MS_U8 *DevCap){    MS_U8 uctemp = 0;    ucMHLFunctionCapability = mhal_mhl_initial(edid, DevCap, ucMHLVenderID);    if(DevCap != NULL)    {        for(uctemp = 0; uctemp < MHL_DEVICE_CAPABILITY_SIZE; uctemp++)        {            MhlDevCap_tbl[uctemp] = DevCap[uctemp];        }        if(mdrv_mhl_GetEnhanceCbusFlag()) // Chip support MHL 3.0        {            for(uctemp = 0; uctemp < MHL_XDEVICE_CAPABILITY_SIZE; uctemp++)            {                MhlDevCap_tbl[MHL_DEVICE_CAPABILITY_SIZE +uctemp] = DevCap[MHL_DEVICE_CAPABILITY_SIZE +uctemp];            }        }        else if(DevCap[MHL_CBUS_VERSION] >= 0x30) // Change MHL version to 2.1        {            MhlDevCap_tbl[MHL_CBUS_VERSION] = 0x21;                        mhal_mhl_LoadDeviceCapability(MhlDevCap_tbl);            msg_mhl(printf("** MHL this chip not supprt MHL 3.0 \r\n"));        }    }}//**************************************************************************//  [Function Name]://                  mdrv_mhl_LoadEDID()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_LoadEDID(MS_U8 *edid){    mhal_mhl_LoadEDID(edid);}//**************************************************************************//  [Function Name]://                  mdrv_mhl_ReadEDID()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_ReadEDID(MS_U16 usSize, MS_U8 *edid){    if(usSize > 0)    {        mhal_mhl_ReadEDID(usSize, edid);    }}//**************************************************************************//  [Function Name]://                  mdrv_mhl_LoadDeviceCapability()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_LoadDeviceCapability(MS_U8 *devcap){    mhal_mhl_LoadDeviceCapability(devcap);}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CheckIsrUsePMPath()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mdrv_mhl_CheckIsrUsePMPath(void){    return GET_MHL_INTERRUPT_USE_PM_IRQ();}//**************************************************************************//  [Function Name]://                  mdrv_mhl_ParsingEDIDfor3D()//  [Description]//                  //  [Arguments]://                  //  [Return]:////**************************************************************************void mdrv_mhl_ParsingEDIDfor3D(MS_U8 *pEdid){    MS_BOOL bDTDParseFinish = FALSE;    MS_U8 uctemp = 0;    MS_U8 ucValue = 0;    MS_U8 ucIndex = 0;    MS_U8 ucDTDTimingNum = 0;    MS_U8 ucThirdDTDStart = 0;    MS_U8 ucDTDTiming[MHL_3D_DTD_INFORMATION_LENGTH];    if(pEdid != NULL)    {        // Parsing 3D DTD information Start        if(_mdrv_mhl_DTDPresentinEDID(&pEdid[MHL_EDID_FIRST_DTD_START])) // Check first DTD        {            ucValue = _mdrv_mhl_InsertDTD3DInformation(MHL_3D_FIRST_DTD, pEdid[MHL_EDID_FIRST_DTD_START +MHL_EDID_DTD_LENGTH -1]);            ucDTDTiming[MHL_3D_FIRST_DTD] = _mdrv_mhl_GetDTD3DTimingInformation(&pEdid[MHL_EDID_FIRST_DTD_START]);        }        else // First DTD absent        {            bDTDParseFinish = TRUE;                        ucDTDTimingNum = 0;                        msg_mhl(printf("** MHL first DTD absent in port %c\r\n", MHL_INPUT_PORT(GET_MHL_CBUS_SELECT_PATH())));        }        if(!bDTDParseFinish)        {            if(_mdrv_mhl_DTDPresentinEDID(&pEdid[MHL_EDID_SECOND_DTD_START])) // Check second DTD            {                ucValue = _mdrv_mhl_InsertDTD3DInformation(MHL_3D_SECOND_DTD, pEdid[MHL_EDID_SECOND_DTD_START +MHL_EDID_DTD_LENGTH -1]);                ucDTDTiming[MHL_3D_SECOND_DTD] = _mdrv_mhl_GetDTD3DTimingInformation(&pEdid[MHL_EDID_SECOND_DTD_START]);            }            else    // Second DTD absent            {                bDTDParseFinish = TRUE;                                ucDTDTimingNum = 1;                                msg_mhl(printf("** MHL second DTD absent in port %c\r\n", MHL_INPUT_PORT(GET_MHL_CBUS_SELECT_PATH())));            }        }        if(pEdid[MHL_EDID_EXTENSION_FLAG] > 0) // Have extend EDID        {            ucThirdDTDStart = MHL_EDID_BLOCK_LENGTH +pEdid[MHL_EDID_RESERVED_DATA_BLOCK];            msg_mhl(printf("** MHL third DTD start at %x in port %c\r\n", ucThirdDTDStart, MHL_INPUT_PORT(GET_MHL_CBUS_SELECT_PATH())));                        if(!bDTDParseFinish)            {                for(uctemp = 0; uctemp <(MHL_3D_DTD_INFORMATION_LENGTH -2); uctemp++)                {                    if(_mdrv_mhl_DTDPresentinEDID(&pEdid[ucThirdDTDStart +MHL_EDID_DTD_LENGTH *uctemp])) // Check others DTD                    {                        ucValue = _mdrv_mhl_InsertDTD3DInformation(MHL_3D_THIRD_DTD +uctemp, pEdid[ucThirdDTDStart +MHL_EDID_DTD_LENGTH *(uctemp +1) -1]);                        ucDTDTiming[MHL_3D_THIRD_DTD +uctemp] = _mdrv_mhl_GetDTD3DTimingInformation(&pEdid[ucThirdDTDStart +MHL_EDID_DTD_LENGTH *uctemp]);                    }                    else    // Last DTD find                    {                        bDTDParseFinish = TRUE;                                                ucDTDTimingNum = uctemp +2;                        msg_mhl(printf("** MHL total have %d DTD in port %c\r\n", ucDTDTimingNum, MHL_INPUT_PORT(GET_MHL_CBUS_SELECT_PATH())));                                                break;                    }                }            }            // Parsing 3D VIC information Start            if(ucThirdDTDStart > (MHL_EDID_RESERVED_DATA_BLOCK +2))            {                if(_mdrv_mhl_ParsingVIC3DInformation(pEdid[MHL_EDID_RESERVED_DATA_BLOCK] -4, &pEdid[MHL_EDID_RESERVED_DATA_BLOCK +2]))                {                    // 3D Present                    for(uctemp = 0; uctemp <ucDTDTimingNum; uctemp++)                    {                        ucIndex = GET_MHL_3D_DTD_INFORMATION(uctemp);                        switch(ucDTDTiming[uctemp])                        {                            case MHL_3D_PRESENT_VIC_1920x1080p24Hz: // Support frame packing with top and bottom                            case MHL_3D_PRESENT_VIC_1280x720p60Hz: // Support frame packing with top and bottom                            case MHL_3D_PRESENT_VIC_1280x720p50Hz: // Support frame packing with top and bottom                                ucIndex = MASKSET(ucIndex, (MHL_3D_FS_SUPPORT |MHL_3D_TB_SUPPORT), (MHL_3D_FS_SUPPORT |MHL_3D_TB_SUPPORT));                                SET_MHL_3D_DTD_INFORMATION(uctemp, ucIndex);                                                                break;                            case MHL_3D_PRESENT_VIC_1920x1080i60Hz: // Support side by side                            case MHL_3D_PRESENT_VIC_1920x1080i50Hz: // Support side by side                                ucIndex = MASKSET(ucIndex, MHL_3D_LR_SUPPORT, MHL_3D_LR_SUPPORT);                                SET_MHL_3D_DTD_INFORMATION(uctemp, ucIndex);                                                                break;                                                            default:                                                                break;                        };                        if(ucIndex > 0)                        {                            ucValue = uctemp +1;                        }                    }                }            }        }        // Parsing 3D DTD information End        SET_MHL_3D_TOT_ENT_DTD(ucValue);    }}//**************************************************************************//  [Function Name]://                  mdrv_mhl_GetDTDBurstfor3D()//  [Description]//                  //  [Arguments]://                  //  [Return]:////**************************************************************************MS_BOOL mdrv_mhl_GetDTDBurstfor3D(MS_U8 *pData, MS_U8 *uc3DSequence){    MS_BOOL bFinish = FALSE;    MS_U8 uctemp = 0;    MS_U8 ucDTDCount = 0;    MS_U8 ucSequence = GET_MHL_WRITE_BURST_SEQUENCE();    ucDTDCount = ucSequence *MHL_3D_SEQUENCE_LENGTH;    pData[0] = (MHL_BURST_ID_3D_DTD >> 8);    pData[1] = (MHL_BURST_ID_3D_DTD &BMASK(7:0));    pData[3] = GET_MHL_3D_TOT_ENT_DTD();    if(GET_MHL_3D_TOT_ENT_DTD() == 0)    {        bFinish = TRUE;    }    for(uctemp = 0; uctemp < MHL_3D_SEQUENCE_LENGTH; uctemp++)    {        if((!bFinish) && ((ucDTDCount +uctemp) == (GET_MHL_3D_TOT_ENT_DTD() -1)))        {            bFinish = TRUE;        }                if((ucDTDCount +uctemp) < GET_MHL_3D_TOT_ENT_DTD())        {            pData[6 +uctemp *MHL_3D_ITEM_LENGTH] = 0;            pData[6 +uctemp *MHL_3D_ITEM_LENGTH +1] = GET_MHL_3D_DTD_INFORMATION(ucDTDCount +uctemp) &BMASK(3:0);        }        else        {            pData[6 +uctemp *MHL_3D_ITEM_LENGTH] = 0;            pData[6 +uctemp *MHL_3D_ITEM_LENGTH +1] = 0;        }    }    ucSequence++;        pData[4] = ucSequence;    if(bFinish)    {        pData[5] = GET_MHL_3D_TOT_ENT_DTD() -ucDTDCount;        ucSequence = 0;    }    else    {        pData[5] = MHL_3D_SEQUENCE_LENGTH;    }        pData[2] = _mdrv_mhl_WriteBurstCheckSum(pData);    *uc3DSequence = ucSequence;        return bFinish;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_GetVICBurstfor3D()//  [Description]//                  //  [Arguments]://                  //  [Return]:////**************************************************************************MS_BOOL mdrv_mhl_GetVICBurstfor3D(MS_U8 *pData, MS_U8 *uc3DSequence){    MS_BOOL bFinish = FALSE;    MS_U8 uctemp = 0;    MS_U8 ucVIDCount = 0;    MS_U8 ucSequence = GET_MHL_WRITE_BURST_SEQUENCE();    ucVIDCount = ucSequence *MHL_3D_SEQUENCE_LENGTH;        pData[0] = (MHL_BURST_ID_3D_VIC >> 8);    pData[1] = (MHL_BURST_ID_3D_VIC &BMASK(7:0));    pData[3] = GET_MHL_3D_TOT_ENT_VIC();        if(GET_MHL_3D_TOT_ENT_VIC() == 0)    {        bFinish = TRUE;    }    for(uctemp = 0; uctemp < MHL_3D_SEQUENCE_LENGTH; uctemp++)    {        if((!bFinish) && ((ucVIDCount +uctemp) == (GET_MHL_3D_TOT_ENT_VIC() -1)))        {            bFinish = TRUE;        }                if((ucVIDCount +uctemp) < GET_MHL_3D_TOT_ENT_VIC())        {            pData[6 +uctemp *MHL_3D_ITEM_LENGTH] = 0;            pData[6 +uctemp *MHL_3D_ITEM_LENGTH +1] = GET_MHL_3D_VIC_INFORMATION(ucVIDCount +uctemp) &BMASK(3:0);        }        else        {            pData[6 +uctemp *MHL_3D_ITEM_LENGTH] = 0;            pData[6 +uctemp *MHL_3D_ITEM_LENGTH +1] = 0;        }    }    ucSequence++;        pData[4] = ucSequence;    if(bFinish)    {        pData[5] = GET_MHL_3D_TOT_ENT_VIC() -ucVIDCount;        ucSequence = 0;    }    else    {        pData[5] = MHL_3D_SEQUENCE_LENGTH;    }        pData[2] = _mdrv_mhl_WriteBurstCheckSum(pData);    *uc3DSequence = ucSequence;    return bFinish;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_GetBurstforVirtualChannel()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mdrv_mhl_GetBurstforVirtualChannel(MS_BOOL bVCConfirm, MS_U8 *ucVCSequence, MS_U8 *pData){    MS_BOOL bFinish = FALSE;    MS_U8 uctemp = 0;    MS_U8 ucVCCount = 0;    MS_U8 ucSequence = GET_MHL_WRITE_BURST_SEQUENCE();    MS_U8 ucVCTotalEntry = 0;    MS_U8 ucVCFinishEntry = 0;    MS_U16 usWriteBurstID = MHL_BURST_ID_VC_ASSIGN;    ST_VIRTUAL_CHANNEL_INFO *ucMHLVCInformation = &GET_MHL_VC_INFORMATION(0);    if(bVCConfirm)    {        usWriteBurstID = MHL_BURST_ID_VC_CONFIRM;    }    ucVCFinishEntry = ucSequence *MHL_VC_SEQUENCE_LENGTH;    pData[0] = (usWriteBurstID >> 8);    pData[1] = (usWriteBurstID &BMASK(7:0));    pData[15] = 0;    for(uctemp = 0; uctemp < MHL_VIRTUAL_CHANNEL_LENGTH; uctemp++)    {        if(ucMHLVCInformation[uctemp].bVCConfirm)        {            ucVCTotalEntry++;            if(ucVCFinishEntry > 0)            {                ucVCFinishEntry--;            }            else if(ucVCCount < MHL_VC_SEQUENCE_LENGTH)            {                pData[6 +ucVCCount *MHL_VC_ITEM_LENGTH] = ucMHLVCInformation[uctemp].ucVCNumber;                pData[6 +ucVCCount *MHL_VC_ITEM_LENGTH +1] = ucMHLVCInformation[uctemp].ucVCFeatureID;                if(bVCConfirm)                {                    pData[6 +ucVCCount *MHL_VC_ITEM_LENGTH +2] = ucMHLVCInformation[uctemp].ucVCResponseCode;                }                else                {                    pData[6 +ucVCCount *MHL_VC_ITEM_LENGTH +2] = ucMHLVCInformation[uctemp].ucVCSlotSize;                }                ucVCCount++;            }        }    }    ucSequence++;    pData[3] = ucVCTotalEntry;    pData[4] = ucSequence;    pData[5] = ucVCCount;    pData[2] = _mdrv_mhl_WriteBurstCheckSum(pData);    if(((ucSequence -1) *MHL_VC_SEQUENCE_LENGTH +ucVCCount) == ucVCTotalEntry)    {        bFinish = TRUE;        ucSequence = 0;    }    *ucVCSequence = ucSequence;    return bFinish;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_GetHighEndVideoVIC()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mdrv_mhl_GetHighEndVideoVIC(MS_U8 *ucHEVSequence, MS_U8 *pData){    MS_BOOL bFinish = FALSE;    MS_U8 uctemp = 0;    MS_U8 ucEntryCount = 0;    MS_U8 ucSequence = GET_MHL_WRITE_BURST_SEQUENCE();    MS_U8 ucFinishEntry = 0;    MS_U8 ucTotalEntry = MHL_HEV_VIC_TOTAL_ENTRY;    ucFinishEntry = ucSequence *MHL_HEV_VIC_SEQUENCE_LENGTH;    pData[0] = (MHL_BURST_ID_HEV_VIC >> 8);    pData[1] = (MHL_BURST_ID_HEV_VIC &BMASK(7:0));    pData[3] = MHL_HEV_VIC_TOTAL_ENTRY;    for(uctemp = 0; uctemp < MHL_HEV_VIC_SEQUENCE_LENGTH; uctemp++)    {        if((uctemp +ucFinishEntry) == ucTotalEntry)        {            break;        }        pData[6 +uctemp] = tMHL_HEV_VIC_TABLE[uctemp +ucFinishEntry] >> 8;        pData[7 +uctemp] = tMHL_HEV_VIC_TABLE[uctemp +ucFinishEntry] &BMASK(7:0);        ucEntryCount++;        }    ucSequence++;    pData[4] = ucSequence;    pData[5] = ucEntryCount;    pData[2] = _mdrv_mhl_WriteBurstCheckSum(pData);    if(((ucSequence -1) *MHL_HEV_VIC_SEQUENCE_LENGTH +ucEntryCount) == MHL_HEV_VIC_TOTAL_ENTRY)    {        bFinish = TRUE;        ucSequence = 0;    }    *ucHEVSequence = ucSequence;    return bFinish;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_GetHighEndVideoDTDA()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mdrv_mhl_GetHighEndVideoDTDA(MS_U8 *ucHEVSequence, MS_U8 *pData){    MS_BOOL bFinish = FALSE;    MS_U8 uctemp = 0;    MS_U8 ucEntryCount = 0;    MS_U8 ucSequence = GET_MHL_WRITE_BURST_SEQUENCE();    MS_U8 ucFinishEntry = 0;    MS_U8 ucTotalEntry = MHL_HEV_DTD_TOTAL_ENTRY;    ucFinishEntry = ucSequence *MHL_HEV_DTD_SEQUENCE_LENGTH;    pData[0] = (MHL_BURST_ID_HEV_DTDA >> 8);    pData[1] = (MHL_BURST_ID_HEV_DTDA &BMASK(7:0));    pData[3] = MHL_HEV_DTD_TOTAL_ENTRY;    for(uctemp = 0; uctemp < ucTotalEntry; uctemp++)    {        if(ucFinishEntry > 0)        {            ucFinishEntry--;        }        else if(ucEntryCount < MHL_HEV_DTD_SEQUENCE_LENGTH)        {            ucEntryCount++;        }    }    ucSequence++;    pData[4] = ucSequence;    pData[2] = _mdrv_mhl_WriteBurstCheckSum(pData);    if(((ucSequence -1) *MHL_HEV_DTD_SEQUENCE_LENGTH +ucEntryCount) == MHL_HEV_DTD_TOTAL_ENTRY)    {        bFinish = TRUE;        ucSequence = 0;    }    *ucHEVSequence = ucSequence;    return bFinish;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_GetHighEndVideoDTDB()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mdrv_mhl_GetHighEndVideoDTDB(MS_U8 *ucHEVSequence, MS_U8 *pData){    MS_BOOL bFinish = FALSE;    MS_U8 uctemp = 0;    MS_U8 ucEntryCount = 0;    MS_U8 ucSequence = GET_MHL_WRITE_BURST_SEQUENCE();    MS_U8 ucFinishEntry = 0;    MS_U8 ucTotalEntry = MHL_HEV_DTD_TOTAL_ENTRY;    ucFinishEntry = ucSequence *MHL_HEV_DTD_SEQUENCE_LENGTH;    pData[0] = (MHL_BURST_ID_HEV_DTDB >> 8);    pData[1] = (MHL_BURST_ID_HEV_DTDB &BMASK(7:0));    pData[3] = MHL_HEV_DTD_TOTAL_ENTRY;    for(uctemp = 0; uctemp < ucTotalEntry; uctemp++)    {        if(ucFinishEntry > 0)        {            ucFinishEntry--;        }        else if(ucEntryCount < MHL_HEV_DTD_SEQUENCE_LENGTH)        {            ucEntryCount++;        }    }    ucSequence++;    pData[4] = ucSequence;    pData[2] = _mdrv_mhl_WriteBurstCheckSum(pData);    if(((ucSequence -1) *MHL_HEV_DTD_SEQUENCE_LENGTH +ucEntryCount) == MHL_HEV_DTD_TOTAL_ENTRY)    {        bFinish = TRUE;        ucSequence = 0;    }    *ucHEVSequence = ucSequence;    return bFinish;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_GetAudioDataTunnel()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mdrv_mhl_GetAudioDataTunnel(MS_U8 *ucADTSequence, MS_U8 *pData){    MS_BOOL bFinish = FALSE;    MS_U8 uctemp = 0;    MS_U8 ucEntryCount = 0;    MS_U8 ucSequence = GET_MHL_WRITE_BURST_SEQUENCE();    MS_U8 ucFinishEntry = 0;    MS_U8 ucTotalEntry = MHL_AUDIO_TUNNEL_TOTAL_ENTRY;    ucFinishEntry = ucSequence *MHL_AUDIO_TUNNEL_SEQUENCE_LENGTH;    pData[0] = (MHL_BURST_ID_ADT_BURSTID >> 8);    pData[1] = (MHL_BURST_ID_ADT_BURSTID &BMASK(7:0));    pData[3] = MHL_AUDIO_TUNNEL_TOTAL_ENTRY;    if((ucSequence == 0) && (MHL_AUDIO_TUNNEL_SADB_RNTRY > 0)) // Support speaker allocation data block    {        pData[5] = 1;    }        for(uctemp = 0; uctemp < MHL_AUDIO_TUNNEL_SEQUENCE_LENGTH; uctemp++)    {        if((uctemp +ucFinishEntry) == ucTotalEntry)        {            break;        }        pData[7 +uctemp] = tMHL_AUDIO_TUNNEL_TABLE[uctemp +ucFinishEntry] >> 16;        pData[8 +uctemp] = tMHL_AUDIO_TUNNEL_TABLE[uctemp +ucFinishEntry] >> 8;        pData[9 +uctemp] = tMHL_AUDIO_TUNNEL_TABLE[uctemp +ucFinishEntry] &BMASK(7:0);        ucEntryCount++;    }    ucSequence++;    pData[4] = ucSequence;    pData[6] = ucEntryCount;    pData[2] = _mdrv_mhl_WriteBurstCheckSum(pData);    if(((ucSequence -1) *MHL_AUDIO_TUNNEL_SEQUENCE_LENGTH +ucEntryCount) == MHL_AUDIO_TUNNEL_TOTAL_ENTRY)    {        bFinish = TRUE;        ucSequence = 0;    }    *ucADTSequence = ucSequence;    return bFinish;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_GeteMSCSupportInformation()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mdrv_mhl_GeteMSCSupportInformation(MS_U8 *ucMSCSequence, MS_U8 *pData){    MS_BOOL bFinish = FALSE;    MS_U8 uctemp = 0;    MS_U8 ucEntryCount = 0;    MS_U8 ucSequence = GET_MHL_WRITE_BURST_SEQUENCE();    MS_U8 ucFinishEntry = 0;    MS_U8 ucTotalEntry = MHL_EMSC_SUPPORT_TOTAL_ENTRY;    ucFinishEntry = ucSequence *MHL_EMSC_SUPPORT_SEQUENCE_LENGTH;    pData[0] = (MHL_BURST_ID_EMSC_SUPPORT >> 8);    pData[1] = (MHL_BURST_ID_EMSC_SUPPORT &BMASK(7:0));    pData[3] = MHL_EMSC_SUPPORT_TOTAL_ENTRY;    for(uctemp = 0; uctemp < MHL_EMSC_SUPPORT_SEQUENCE_LENGTH; uctemp++)    {        if((uctemp +ucFinishEntry) == ucTotalEntry)        {            break;        }        pData[6 +uctemp] = tMHL_EMSC_SUPPORT_TABLE[uctemp +ucFinishEntry] >> 8;        pData[7 +uctemp] = tMHL_EMSC_SUPPORT_TABLE[uctemp +ucFinishEntry] &BMASK(7:0);        ucEntryCount++;    }    ucSequence++;    pData[4] = ucSequence;    pData[5] = ucEntryCount;    pData[2] = _mdrv_mhl_WriteBurstCheckSum(pData);    if(((ucSequence -1) *MHL_EMSC_SUPPORT_SEQUENCE_LENGTH +ucEntryCount) == MHL_EMSC_SUPPORT_TOTAL_ENTRY)    {        bFinish = TRUE;        ucSequence = 0;    }    *ucMSCSequence = ucSequence;    return bFinish;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_SetVenderID()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_SetVenderID(MS_U8 ucVenderID){    ucMHLVenderID = ucVenderID;        mhal_mhl_SetVenderID(ucVenderID);}//**************************************************************************//  [Function Name]://                  mdrv_mhl_InvertCableDetect()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_InvertCableDetect(MS_BOOL bCableDetectInvert){    MS_U8 uctemp = 0;        for(uctemp = 0; uctemp < MHL_CBUS_SELECT_MASK ;uctemp++)    {        mhal_mhl_InvertCableDetect(uctemp, bCableDetectInvert);    }}//**************************************************************************//  [Function Name]://                  mdrv_mhl_VbusConfigSetting()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_VbusConfigSetting(MS_U8 ucState){    MS_U8 uctemp = 0;        for(uctemp = 0; uctemp < MHL_CBUS_SELECT_MASK ;uctemp++)    {        mhal_mhl_VbusConfigSetting(uctemp, ucState);    }}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CableDetectPadSetting()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_CableDetectPadSetting(MS_U8 ucSelect){    mhal_mhl_CableDetectPadSetting(ucSelect);}//**************************************************************************//  [Function Name]://                  mdrv_mhl_GetInputPort()//  [Description]//                  MHL get current input port//  [Arguments]:////  [Return]://                  //**************************************************************************MS_U8 mdrv_mhl_GetInputPort(void){    return mhal_mhl_GetInputPort();}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CheckInputPort()//  [Description]//                  MHL check current input port//  [Arguments]:////  [Return]://                  //**************************************************************************MS_BOOL mdrv_mhl_CheckInputPort(void){        return mhal_mhl_CheckInputPort(GET_MHL_CBUS_SELECT_PATH());}//**************************************************************************//  [Function Name]://                  mdrv_mhl_GetCbusPath()//  [Description]//                  MHL get current Cbus path//  [Arguments]:////  [Return]://                  //**************************************************************************MS_U8 mdrv_mhl_GetCbusPath(void){        return GET_MHL_CBUS_SELECT_PATH();}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CheckSendCommand()//  [Description]//                  //  [Arguments]:////  [Return]://                  //**************************************************************************MS_BOOL mdrv_mhl_CheckSendCommand(MS_BOOL bForceSendCommand){        MS_BOOL bSendCommand = FALSE;    MS_BOOL bMHLPort = mdrv_mhl_CheckInputPort();    if(bMHLPort && mhal_mhl_CheckPIPWindow()) // MHL port and scaler mux on    {        bSendCommand = TRUE;    }    else if(bForceSendCommand && GET_MHL_ENABLE_FORCE_SEND())    {        bSendCommand = TRUE;    }        return bSendCommand;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CableDetect()//  [Description]//                  MHL cable detection//  [Arguments]:////  [Return]://                  TRUE: MHL cable plugged//                  FALSE: MHL cable unplugged//**************************************************************************MS_BOOL mdrv_mhl_CableDetect(void){    MS_U8 bFlag = FALSE;    MS_U8 bCableDetect = FALSE;    MS_U8 uctemp = 0;    // Check all cable detect of Cbus select    for(uctemp = 0; uctemp < MHL_CBUS_SELECT_MASK ;uctemp++)    {        bFlag = mhal_mhl_CableDetect(uctemp);                if(bFlag)        {            if(!GET_MHL_CABLE_DETECT_PORT(uctemp))            {                mhal_mhl_CablePlugProc(uctemp);                                msg_mhl(printf("** MHL Cable plugged!! port %c\r\n", MHL_INPUT_PORT(uctemp)));                                SET_MHL_CABLE_DETECT_PORT(uctemp);            }        }        else        {            if(GET_MHL_CABLE_DETECT_PORT(uctemp))            {                mhal_mhl_CableRemoveProc(uctemp);                _mdrv_mhl_ECbusStatusClear();                                msg_mhl(printf("** MHL Cable remove~~~ port %c\r\n", MHL_INPUT_PORT(uctemp)));                                CLR_MHL_CABLE_DETECT_PORT(uctemp);            }            			mhal_mhl_Accumulator_Clr(uctemp);        }        // Report cable detect of current Cbus select        if(uctemp == GET_MHL_CBUS_SELECT_PATH())        {            bCableDetect = bFlag;        }    }        return bCableDetect;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CheckInputCbusSelect//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mdrv_mhl_CheckInputCbusSelect(MS_U8 ucPort){    MS_BOOL bFlag = FALSE;    MS_U8 ucCbusSelect = mhal_mhl_GetCbusSelect(ucPort); // Cbus select of current port    if(_mdrv_mhl_GetCableDetectPort(ucPort)) // Current port cable detect high    {        if(GET_MHL_CBUS_SELECT_PATH() != ucCbusSelect) // Current Cbus select not in on line port        {            bFlag = TRUE;        }    }    else // Current port cable detect low    {        if(!GET_MHL_CABLE_DETECT_PORT(GET_MHL_CBUS_SELECT_PATH())) // Current cable detect not high, search next cable detect high port        {            ucCbusSelect = _mdrv_mhl_SearchNextCbusSelect(GET_MHL_CBUS_SELECT_PATH());            if(GET_MHL_CBUS_SELECT_PATH() != ucCbusSelect)            {                bFlag = TRUE;            }        }    }    if(bFlag) // Cbus select mux change    {        mhal_mhl_CbusSelectSetMux(ucCbusSelect);                    SET_MHL_CBUS_SELECT_PATH(ucCbusSelect);        msg_mhl(printf("** MHL Cbus switch mux to port %c\r\n", MHL_INPUT_PORT(ucCbusSelect)));    }        return bFlag;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_AutoSwitchCbusSelect//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mdrv_mhl_AutoSwitchCbusSelect(void){    MS_BOOL bFlag = FALSE;    MS_U8 ucCbusSelect = GET_MHL_CBUS_SELECT_PATH();        if(!_mdrv_mhl_GetCableDetectPort(mhal_mhl_GetInputPort())) // Check current port cable detect    {        ucCbusSelect = _mdrv_mhl_SearchNextCbusSelect(GET_MHL_CBUS_SELECT_PATH());        if(GET_MHL_CBUS_SELECT_PATH() != ucCbusSelect)        {            bFlag = TRUE;        }    }    if(bFlag) // Cbus select mux change    {        mhal_mhl_CbusSelectSetMux(ucCbusSelect);                    SET_MHL_CBUS_SELECT_PATH(ucCbusSelect);        msg_mhl(printf("** MHL Cbus switch mux to port %c\r\n", MHL_INPUT_PORT(ucCbusSelect)));    }    return bFlag;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CbusInitialProc()//  [Description]//                  //  [Arguments]://                  //  [Return]:////**************************************************************************MS_BOOL mdrv_mhl_CbusInitialProc(void){    MS_U8 ucCbusSelect = mhal_mhl_GetCbusSelect(mhal_mhl_GetInputPort()); // Cbus select of current port        // Set Cbus select to current port    SET_MHL_CBUS_SELECT_PATH(ucCbusSelect);    if(!mdrv_mhl_CableDetect())    {        ucCbusSelect = _mdrv_mhl_SearchNextCbusSelect(GET_MHL_CBUS_SELECT_PATH());    }    if(!GET_MHL_CABLE_DETECT_ALL())    {        ucCbusSelect = MHL_CBUS_SELECT_PORT_INITIAL;    }    mhal_mhl_CbusSelectSetMux(ucCbusSelect);            SET_MHL_CBUS_SELECT_PATH(ucCbusSelect);    msg_mhl(printf("** MHL Cbus initial mux to port %c\r\n", MHL_INPUT_PORT(ucCbusSelect)));        return GET_MHL_CABLE_DETECT_PORT(ucCbusSelect);}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CbusConnectProc()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_CbusConnectProc(void){    MS_U8 ucCbusSelect = GET_MHL_CBUS_SELECT_PATH();        mhal_mhl_CbusConnectProc(ucCbusSelect);    SET_MHL_INPUT_CLOCK_MODE(CBUS_CLOCK_NORMAL_24BIT);    msg_mhl(printf("** MHL Cbus connected~~ ^Q^ port %c\r\n", MHL_INPUT_PORT(ucCbusSelect)));}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CbusStucktoLowProc()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************MS_U8 mdrv_mhl_CbusStucktoLowProc(void){    MS_U8 ucCbusSelect = GET_MHL_CBUS_SELECT_PATH();        mhal_mhl_CbusStucktoLowProc(ucCbusSelect);    if(GET_MHL_INPUT_CLOCK_MODE() == CBUS_CLOCK_PACKET_PIXEL)    {        mhal_mhl_ClockModeSwitchProc(ucCbusSelect, FALSE);        SET_MHL_INPUT_CLOCK_MODE(CBUS_CLOCK_NORMAL_24BIT);    }    _mdrv_mhl_ECbusStatusClear();    return ucCbusSelect;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_ClockModeSwitch()//  [Description]://                  MHL Cbus clock mode select//  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_ClockModeSwitch(MS_U8 ucSelect){    MS_BOOL bPPmode = FALSE;    MS_U8 ucCbusSelect = GET_MHL_CBUS_SELECT_PATH();        if(GET_MHL_INPUT_CLOCK_MODE() != ucSelect)    {        if(ucSelect == CBUS_CLOCK_PACKET_PIXEL)        {            bPPmode = TRUE;            msg_mhl(printf("** MHL switch to PPmode port %c\r\n", MHL_INPUT_PORT(ucCbusSelect)));        }        else if(ucSelect == CBUS_CLOCK_NORMAL_24BIT)        {            msg_mhl(printf("** MHL switch back to 24 bit mode port %c\r\n", MHL_INPUT_PORT(ucCbusSelect)));        }        mhal_mhl_ClockModeSwitchProc(ucCbusSelect, bPPmode);        mhal_mhl_CDRModeMonitor(ucCbusSelect, FALSE);        SET_MHL_INPUT_CLOCK_MODE(ucSelect);    }}//**************************************************************************//  [Function Name]://                  mdrv_mhl_SourceChangeProc()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_SourceChangeProc(MS_U8 ucPort){    MS_U8 ucCbusSelect = GET_MHL_CBUS_SELECT_PATH();        mhal_mhl_SourceChangeProc(ucCbusSelect);    if(GET_MHL_INPUT_CLOCK_MODE() == CBUS_CLOCK_PACKET_PIXEL)    {        mhal_mhl_ClockModeSwitchProc(ucCbusSelect, TRUE);    }}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CBusCheckBCHError()//  [Description]://                  MHL Cbus check BCH error//  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mdrv_mhl_CBusStablePolling(MS_BOOL bFlag){    if(mhal_mhl_CDRModeMonitor(GET_MHL_CBUS_SELECT_PATH(), bFlag))    {        bFlag = mhal_mhl_CBusCheckBCHError();    }    else    {        bFlag = FALSE;    }    return bFlag;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CbusWakeupIntSetting()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_CbusWakeupIntSetting(MS_BOOL bFlag){    MS_U8 ucCbusSelect = GET_MHL_CBUS_SELECT_PATH();        mhal_mhl_CbusWakeupIntSetting(ucCbusSelect, bFlag);}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CbusIsolate()//  [Description]//                  MHL cable isolate//  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_CbusIsolate(MS_BOOL bFlag){    MS_U8 ucCbusSelect = GET_MHL_CBUS_SELECT_PATH();        mhal_mhl_CbusIsolate(ucCbusSelect, bFlag);}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CbusStatus()//  [Description]://                  MHL Cbus status//  [Arguments]:////  [Return]:////**************************************************************************MS_U16 mdrv_mhl_CbusStatus(void){    return (mhal_mhl_CbusStatus());}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CbusIsMscMsgReceived()//  [Description]////  [Arguments]:////  [Return]://                  TRUE://                  FALSE://**************************************************************************MS_BOOL mdrv_mhl_CbusIsMscMsgReceived(void){    return mhal_mhl_CbusIsMscMsgReceived();}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CbusStucktoLowFlag()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mdrv_mhl_CbusStucktoLowFlag(void){    MS_BOOL bindex = mhal_mhl_CbusStucktoLowFlag();    if(bindex)    {        mhal_mhl_CbusStucktoLow(FALSE);    }        return bindex;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CbusWakeupIntFlag()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mdrv_mhl_CbusWakeupIntFlag(void){    MS_BOOL bindex = mhal_mhl_CbusWakeupIntFlag();    if(bindex)    {        mhal_mhl_CbusWakeupInterrupt(FALSE);    }        return bindex;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_GetECbusStateChangeFlag()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mdrv_mhl_GetECbusStateChangeFlag(void){    return mhal_mhl_GetECbusStateChangeFlag();}//**************************************************************************//  [Function Name]://                  mdrv_mhl_DriverControl()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mdrv_mhl_CbusIntCB(CbusReq_S *preq, MS_BOOL *bflag){    return mhal_mhl_CbusIntCB(&(preq->rcState), &(preq->cmd), &(preq->msgData[0]), &(preq->len), bflag);}//**************************************************************************//  [Function Name]://                  mdrv_mhl_GetDevCap//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_U8 mdrv_mhl_GetDevCap(MS_U8 ucIndex){    return (MhlDevCap_tbl[ucIndex]);}//**************************************************************************//  [Function Name]://                  mdrv_mhl_GetVenderID//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_U8 mdrv_mhl_GetVenderID(void){    return ucMHLVenderID;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_GetDDCErrorCode//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_U8 mdrv_mhl_GetDDCErrorCode(void){    return (mhal_mhl_GetDDCErrorCode());}//**************************************************************************//  [Function Name]://                  mdrv_mhl_Cbus_SetPathEn()//  [Description]://                  MHL Cbus status//  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_Cbus_SetPathEn(MS_BOOL bFlag){    mhal_mhl_Cbus_SetPathEn(bFlag);}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CbusReply//  [Description]//                  MHL Cbus Response//  [Arguments]://                  ctrlpky: ACK / NACK / ABORT//                  bflag: TRUE means ACK with Tx required data. Use in "MSC_READ_DEVCAP", "MSC_GET_STATE" and "MSC_GET_VENDOR_ID"//                  databuf: Tx required data//  [Return]://                  TRUE: success//                  FALSE: fail//**************************************************************************MS_BOOL mdrv_mhl_CbusReply (MS_U8 ctrlpky, MS_BOOL bflag, MS_U8 databuf){    MS_BOOL bIndex = TRUE;    MS_U8 ucCounter = 10;    mhalCbusFifo_S pCbusFifo = {0};    switch(ctrlpky)    {        case MSC_ACK:            pCbusFifo.lens = bflag ? 2 : 1;            pCbusFifo.databuf[0] = _mdrv_mhl_CbusSetPacket(MSC_HEADER, CBUS_CONTROL, MSC_ACK);            if(bflag)            {                pCbusFifo.databuf[1] = _mdrv_mhl_CbusSetPacket(MSC_HEADER, CBUS_DATA, databuf);            }            break;        case MSC_NACK:            pCbusFifo.lens = 1;            pCbusFifo.databuf[0] = _mdrv_mhl_CbusSetPacket(MSC_HEADER, CBUS_CONTROL, MSC_NACK);            break;        case MSC_ABORT:            pCbusFifo.lens = 1;            pCbusFifo.databuf[0] = _mdrv_mhl_CbusSetPacket(MSC_HEADER, CBUS_CONTROL, MSC_ABORT);            break;        case MSC_GET_STATE:        case MSC_GET_VENDOR_ID:        case MSC_GET_DDC_ERRORCODE:        case MSC_GET_MSC_ERRORCODE:            pCbusFifo.lens = 1;            pCbusFifo.databuf[0] = _mdrv_mhl_CbusSetPacket(MSC_HEADER, CBUS_DATA, databuf);            break;        default:            bIndex = FALSE;            break;    }    if(bIndex)    {        for(;ucCounter > 0; ucCounter--)        {            if(mhal_mhl_CBusWrite(&pCbusFifo))            {                break;            }            else            {                msg_mhl(printf("@@Cbus Tx is busy = 0x%x", ctrlpky));            }        }        if(ucCounter == 0)        {            bIndex = FALSE;        }    }    return bIndex;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CBusWriteCmd()//  [Description]://                  MHL Cbus send command//  [Arguments]:////  [Return]://                  TRUE: Cbus command send successfully//                  FALSE: Cbus command send fail//**************************************************************************MS_BOOL mdrv_mhl_CBusWriteCmd(CbusReq_S *pReq){    MS_BOOL bIndex = TRUE;    MS_U8 uctemp = 0;    mhalCbusFifo_S pCbusFifo;    pCbusFifo.databuf[0] = _mdrv_mhl_CbusSetPacket(MSC_HEADER, CBUS_CONTROL, pReq->cmd);    switch(pReq->cmd)    {        case MSC_ACK:            pCbusFifo.lens = pReq->len;            //pCbusFifo.databuf[0] = _mdrv_mhl_CbusSetPacket(MSC_HEADER, CBUS_CONTROL, MSC_ACK);            if(pReq->len == 2)            {                // payload 2                pCbusFifo.databuf[1] = _mdrv_mhl_CbusSetPacket(MSC_HEADER, CBUS_DATA, pReq->msgData[0]);            }            break;        case MSC_NACK:            pCbusFifo.lens = 1;            //pCbusFifo.databuf[0] = _mdrv_mhl_CbusSetPacket(MSC_HEADER, CBUS_CONTROL, MSC_NACK);            break;        case MSC_ABORT:            pCbusFifo.lens = 1;            //pCbusFifo.databuf[0] = _mdrv_mhl_CbusSetPacket(MSC_HEADER, CBUS_CONTROL, MSC_ABORT);            break;        case MSC_WRITE_STAT_OR_SET_INT: // 0x60        case MSC_WRITE_XSTAT: // 0x70            // payload 1            //pCbusFifo.databuf[0] = _mdrv_mhl_CbusSetPacket(MSC_HEADER, CBUS_CONTROL, MSC_WRITE_STAT_OR_SET_INT);            // payload 2            pCbusFifo.databuf[1] = _mdrv_mhl_CbusSetPacket(MSC_HEADER, CBUS_DATA, pReq->msgData[0]);            // payload 3            pCbusFifo.databuf[2] = _mdrv_mhl_CbusSetPacket(MSC_HEADER, CBUS_DATA, pReq->msgData[1]);            // message length            pCbusFifo.lens = 3;            break;        case MSC_READ_DEVCAP: // 0x61        case MSC_READ_XDEVCAP: // 0x71            // payload 1            //pCbusFifo.databuf[0] = _mdrv_mhl_CbusSetPacket(MSC_HEADER, CBUS_CONTROL, MSC_READ_DEVCAP);            // payload 2            pCbusFifo.databuf[1] = _mdrv_mhl_CbusSetPacket(MSC_HEADER, CBUS_DATA, pReq->msgData[0]);            // message length            pCbusFifo.lens = 2;            break;        case MSC_GET_STATE: // 0x62        case MSC_GET_VENDOR_ID: // 0x63        case MSC_SET_HPD: // 0x64        case MSC_CLR_HPD: // 0x65        case MSC_GET_SC1_ERRORCODE: // 0x69 - Get channel 1 command error code        case MSC_GET_DDC_ERRORCODE: // 0x6A - Get DDC channel command error code.        case MSC_GET_MSC_ERRORCODE: // 0x6B - Get MSC command error code.        case MSC_GET_SC3_ERRORCODE: // 0x6D - Get channel 3 command error code.            // payload 1            //pCbusFifo.databuf[0] = _mdrv_mhl_CbusSetPacket(MSC_HEADER, CBUS_CONTROL, pReq->cmd);            // message length            pCbusFifo.lens = 1;            break;        case MSC_MSC_MSG: // 0x68            // payload 1            //pCbusFifo.databuf[0] = _mdrv_mhl_CbusSetPacket(MSC_HEADER, CBUS_CONTROL, MSC_MSC_MSG);            // payload 2            pCbusFifo.databuf[1] = _mdrv_mhl_CbusSetPacket(MSC_HEADER, CBUS_DATA, pReq->msgData[0]);            // payload 3            pCbusFifo.databuf[2] = _mdrv_mhl_CbusSetPacket(MSC_HEADER, CBUS_DATA, pReq->msgData[1]);            // message length            pCbusFifo.lens = 3;            break;        case MSC_WRITE_BURST: // 0x6C            // payload 1            //pCbusFifo.databuf[0] = _mdrv_mhl_CbusSetPacket(MSC_HEADER, CBUS_CONTROL, MSC_WRITE_BURST);            // payload 2 ~ 17            for(uctemp =0; uctemp <pReq->len; uctemp++) // offset packet + the maxi 16 packets            {                pCbusFifo.databuf[uctemp +1] = _mdrv_mhl_CbusSetPacket(MSC_HEADER, CBUS_DATA, pReq->msgData[uctemp]);            }            // EOF            pCbusFifo.databuf[pReq->len +1] = _mdrv_mhl_CbusSetPacket(MSC_HEADER, CBUS_CONTROL, MSC_EOF);            // message length            pCbusFifo.lens = pReq->len +2;            break;        default:            bIndex = FALSE;            break;    }    if(bIndex)    {        if(!mhal_mhl_CBusWrite(&pCbusFifo))        {            //msg_mhl(printf("@@Cbus Tx is busy = 0x%x\r\n", pReq->cmd));            return FALSE;        }        //gMHLInfo.MhlCbusInfo.timeout = CBUS_COMMAND_TIMEOUT_SECS*1000/DEM_POLLING_DELAY; // timeout reset.    }    return bIndex;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CbusControl()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_CbusControl(MS_U8 ucState){    MS_U8 ucCbusSelect = GET_MHL_CBUS_SELECT_PATH();        switch(ucState)    {        case MHL_CBUS_ISOLATION_ON:            mhal_mhl_CbusIsolate(ucCbusSelect, TRUE);            break;        case MHL_CBUS_ISOLATION_OFF:            mhal_mhl_CbusIsolate(ucCbusSelect, FALSE);            break;        case MHL_CBUS_FLOATING_ON:            mhal_mhl_CbusFloating(TRUE);            break;        case MHL_CBUS_FLOATING_OFF:            mhal_mhl_CbusFloating(FALSE);            break;        case MHL_VBUS_HW_DETCET:            mhal_mhl_VbusCharge(ucCbusSelect, VBUS_HW_DETECT);            break;                    case MHL_VBUS_CHARGE_ON:            mhal_mhl_VbusCharge(ucCbusSelect, VBUS_SW_CHARGE);            break;        case MHL_VBUS_CHARGE_OFF:            mhal_mhl_VbusCharge(ucCbusSelect, VBUS_SW_UNCHARGE);            break;                    default:                        break;    }}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CbusConfigControl()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_CbusConfigControl(MS_BOOL bState){    MS_U8 uctemp = 0;        if(bState)    {        //mhal_mhl_CbusFloating(TRUE);        //mhal_mhl_CbusIsolate(TRUE);        //mhal_mhl_VbusCharge(FALSE);    }    else    {        for(uctemp = 0; uctemp < MHL_CBUS_SELECT_MASK; uctemp++)        {            mhal_mhl_CbusIsolate(uctemp, FALSE);            mhal_mhl_VbusCharge(uctemp, VBUS_HW_DETECT);        }                mhal_mhl_CbusFloating(FALSE);    }}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CbusPadConfigSwitch()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_CbusPadConfigSwitch(MS_BOOL bFlag){    MS_U8 ucCbusSelect = GET_MHL_CBUS_SELECT_PATH();        mhal_mhl_CbusPadConfigSwitch(ucCbusSelect, bFlag);}//**************************************************************************//  [Function Name]://                  mdrv_mhl_RtermControlHWMode()//  [Description]//                  //  [Arguments]:////  [Return]://                  //**************************************************************************void mdrv_mhl_RtermControlHWMode(MS_BOOL bFlag){    MS_U8 ucCbusSelect = GET_MHL_CBUS_SELECT_PATH();        mhal_mhl_RtermControlHWMode(ucCbusSelect, bFlag);}//**************************************************************************//  [Function Name]://                  mdrv_mhl_AdjustSettingIControl()//  [Description]//                  //  [Arguments]:////  [Return]://                  //**************************************************************************void mdrv_mhl_AdjustSettingIControl(MS_U8 ucIControl){    mhal_mhl_AdjustSettingIControl(ucIControl);}//**************************************************************************//  [Function Name]://                  mdrv_mhl_AdjustImpedanceSetting()//  [Description]//                  //  [Arguments]:////  [Return]://                  //**************************************************************************void mdrv_mhl_AdjustImpedanceSetting(MS_U8 ucImpedance){    mhal_mhl_AdjustImpedanceSetting(ucImpedance);}//**************************************************************************//  [Function Name]://                  mdrv_mhl_GetRAPEnableFlag()//  [Description]//                  //  [Arguments]:////  [Return]://                  //**************************************************************************MS_BOOL mdrv_mhl_GetRAPEnableFlag(void){    MS_BOOL bRAPEnable = FALSE;    if(!mdrv_mhl_CheckInputPort())    {        bRAPEnable = TRUE;    }    else if(!mhal_mhl_CheckPIPWindow())    {        bRAPEnable = TRUE;    }    else if(mhal_mhl_GetSignalStableFlag())    {        bRAPEnable = TRUE;    }        return bRAPEnable;}#if(MHL_CBUS_OPERATION_MODE == MHL_CBUS_HW_REPLY_MODE)//**************************************************************************//  [Function Name]://                  mdrv_mhl_CheckSRAMReceiveBuffer()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mdrv_mhl_CheckSRAMReceiveBuffer(void){    return mhal_mhl_CheckSRAMReceiveBuffer();}//**************************************************************************//  [Function Name]://                  mdrv_mhl_GetSRAMReceiveData()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************MS_U16 mdrv_mhl_GetSRAMReceiveData(void){    return mhal_mhl_GetSRAMReceiveData();}#endif//**************************************************************************//  [Function Name]://                  mdrv_mhl_GetEnhanceCbusFlag()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mdrv_mhl_GetEnhanceCbusFlag(void){    MS_BOOL bECbusSupport = GET_MHL_ECBUS_ENGINE_SUPPORT();        if(MhlDevCap_tbl[MHL_CBUS_VERSION] < 0x30)    {        bECbusSupport = FALSE;    }        return bECbusSupport;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_GetDevcapReadyValue()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************MS_U8 mdrv_mhl_GetDevcapReadyValue(void){    MS_U8 ucDevcapValue = BIT(0);    if(mdrv_mhl_GetEnhanceCbusFlag())    {        ucDevcapValue = ucDevcapValue| BIT(1);    }        return ucDevcapValue;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_GetCbusDisplayMask()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************MS_U8 mdrv_mhl_GetCbusDisplayMask(void){    MS_U8 ucDisplayMask = MHL_CBUS_DISPLAY_MASK;    if(mdrv_mhl_GetEnhanceCbusFlag())    {        ucDisplayMask = ucDisplayMask |MHL_ECBUS_DISPLAY_MASK;    }        return ucDisplayMask;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CheckCbusModeChange()//  [Description]//                  //  [Arguments]://                  //  [Return]:////**************************************************************************MS_BOOL mdrv_mhl_CheckCbusModeChange(MS_U8 ucKeyCode){    MS_BOOL bNotCbusChange = TRUE;    if(ucKeyCode == MHL_RAP_KEY_CBUS_MODE_UP)    {        bNotCbusChange = FALSE;        SET_MHL_ECBUS_STATE(MHL_ECBUS_STATE_RECEIVE_MODE_UP);    }    else if(ucKeyCode == MHL_RAP_KEY_CBUS_MODE_DOWN)    {        bNotCbusChange = FALSE;        SET_MHL_ECBUS_STATE(MHL_ECBUS_STATE_RECEIVE_MODE_DOWN);    }        return bNotCbusChange;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_SetBISTProcTimer()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_SetBISTProcTimer(MS_U16 ucTimeTick){    MS_BOOL bTimeoutFlag = FALSE;    static MS_U16 usTimerCount = 0;    if(ucTimeTick == 0)    {        if(usTimerCount > 0)        {            usTimerCount--;        }        else        {            bTimeoutFlag = TRUE;        }    }    else    {        usTimerCount = ucTimeTick;    }    if(bTimeoutFlag)    {        if(GET_MHL_BIST_PROCESS_STATE() == MHL_CBUS_BIST_ECBUS_SWITCH)        {            SET_MHL_BIST_PROCESS_STATE(MHL_CBUS_BIST_EVENT_FINISH);        }    }}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CbusBISTTriggerProc()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_CbusBISTTriggerProc(MS_U8 ucKeyCode){    MS_BOOL bGeteCbusDuration = FALSE;    MS_BOOL bGetAVLinkDuration = FALSE;    MS_U8 ucBISTDeviceType = MhlDevCap_tbl[MHL_CBUS_DEV_CAT] %BMASK(3:0);    MS_U8 ucBISTeCbusSelect = MhlDevCap_tbl[MHL_CBUS_ECBUS_SPEEDS];    MS_U16 usTimerCount = 0;        if(((ucKeyCode &BIT(3)) == BIT(3)) && ((ucBISTeCbusSelect &BIT(4)) != BIT(4))) // Not support eCbus-D    {        // Chip only support eCbus-S    }    if((ucBISTDeviceType == MHL_DEVICE_SOURCE) || (ucBISTDeviceType == MHL_DEVICE_DIRECT_ATTACH_SOURCE))    {        if((ucKeyCode &BIT(0)) == BIT(0)) // Source device and eCbus Tx        {        }        else if((ucKeyCode &BIT(4)) == BIT(4)) // Source device and AV link Tx        {        }    }    else if((ucBISTDeviceType == MHL_DEVICE_SINK) || (ucBISTDeviceType == MHL_DEVICE_DIRECT_ATTACH_SINK))    {        if((ucKeyCode &BIT(1)) == BIT(1)) // Sink device and eCbus link Rx        {            bGeteCbusDuration = TRUE;        }        else if((ucKeyCode &BIT(5)) == BIT(5)) // Sink device and AV link Rx        {            bGetAVLinkDuration = TRUE;        }    }    if(GET_MHL_BIST_PROCESS_STATE() == MHL_CBUS_BIST_WAIT_TRIGGER)    {        if(bGeteCbusDuration)        {            usTimerCount = GET_MHL_BIST_ECBUS_DURATION();            CLR_MHL_BIST_TRIGGER_AV_LINK();        }        else if(bGetAVLinkDuration)        {            usTimerCount = GET_MHL_BIST_AV_LINK_DURATION();            SET_MHL_BIST_TRIGGER_AV_LINK();        }        if(bGeteCbusDuration || bGetAVLinkDuration)        {            SET_MHL_BIST_PROCESS_STATE(MHL_CBUS_BIST_RECEIVE_TRIGGER);        }    }    if(usTimerCount > 0)    {        mdrv_mhl_SetBISTProcTimer(usTimerCount);    }    msg_mhl(printf("** MHL receive BIST trigger in port %c keycode %d\r\n", MHL_INPUT_PORT(GET_MHL_CBUS_SELECT_PATH()), ucKeyCode));}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CbusBISTRequestStatusProc()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_CbusBISTRequestStatusProc(MS_U8 ucKeyCode){    if(ucKeyCode == MHL_BIST_REQ_RETURN_STATUS)    {        SET_MHL_BIST_PROCESS_STATE(MHL_CBUS_BIST_REQUEST_STATUS);    }    msg_mhl(printf("** MHL receive BIST request status in port %c keycode %d\r\n", MHL_INPUT_PORT(GET_MHL_CBUS_SELECT_PATH()), ucKeyCode));}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CbusBISTStopProc()//  [Description]//                  Disable AV LINK_BIST when currently running//  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_CbusBISTStopProc(MS_U8 ucKeyCode){    if(ucKeyCode == 0) // Key code must be set to 0    {        if(GET_MHL_BIST_PROCESS_STATE() == MHL_CBUS_BIST_ECBUS_SWITCH)        {            SET_MHL_BIST_PROCESS_STATE(MHL_CBUS_BIST_EVENT_FINISH);        }    }    msg_mhl(printf("** MHL receive BIST stop in port %c keycode %d\r\n", MHL_INPUT_PORT(GET_MHL_CBUS_SELECT_PATH()), ucKeyCode));}//**************************************************************************//  [Function Name]://                  mdrv_mhl_BISTModeUpProc()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_BISTModeUpProc(void){    if(GET_MHL_BIST_TRIGGER_AV_LINK())    {    }}//**************************************************************************//  [Function Name]://                  mdrv_mhl_BISTModeDownProc()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_BISTModeDownProc(void){    if(GET_MHL_BIST_TRIGGER_AV_LINK())    {    }}//**************************************************************************//  [Function Name]://                  mdrv_mhl_GetBISTReturnStatus()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_GetBISTReturnStatus(MS_U8 *pData){    MS_U16 usBISTeCbusErrorCount = GET_MHL_BIST_ECBUS_ERROR_CNT();    MS_U16 usBISTAVLinkErrorCount = GET_MHL_BIST_AV_LINK_ERROR_CNT();        pData[0] = (MHL_BURST_ID_BIST_RETURN_STAT >> 8);    pData[1] = (MHL_BURST_ID_BIST_RETURN_STAT &BMASK(7:0));    pData[12] = (usBISTeCbusErrorCount >> 8);    pData[13] = (usBISTeCbusErrorCount &BMASK(7:0));    pData[14] = (usBISTAVLinkErrorCount >> 8);    pData[15] = (usBISTAVLinkErrorCount &BMASK(7:0));    pData[2] = _mdrv_mhl_WriteBurstCheckSum(pData);}//**************************************************************************//  [Function Name]://                  mdrv_mhl_ParsingWriteBurstVCAssign()//  [Description]:////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mdrv_mhl_ParsingWriteBurstVCAssign(MS_U8 *ucWriteBurstData){    MS_BOOL bParsingFinish = FALSE;    MS_U8 uctemp = 0;    MS_U8 ucSequence = ucWriteBurstData[1];    MS_U8 ucNumberEntry = ucWriteBurstData[2];    if(ucNumberEntry +(ucSequence -1) *MHL_VC_SEQUENCE_LENGTH == ucWriteBurstData[0]) // Number entry + (sequece -1) x length = total entry    {        bParsingFinish = TRUE;    }    for(uctemp = 0; uctemp <ucNumberEntry; uctemp++)    {        _mdrv_mhl_InsertVCInformation(TRUE, ucWriteBurstData[uctemp *MHL_VC_SEQUENCE_LENGTH +3], ucWriteBurstData[uctemp *MHL_VC_SEQUENCE_LENGTH +4], ucWriteBurstData[uctemp *MHL_VC_SEQUENCE_LENGTH +5]);    }    return bParsingFinish;}//**************************************************************************//  [Function Name]://                  mdrv_mhl_ParsingWriteBurstVCConfirm()//  [Description]:////  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_ParsingWriteBurstVCConfirm(MS_U8 *ucWriteBurstData){    MS_BOOL bParsingFinish = FALSE;    MS_U8 uctemp = 0;    MS_U8 ucSequence = ucWriteBurstData[1];    MS_U8 ucNumberEntry = ucWriteBurstData[2];    if(ucNumberEntry +(ucSequence -1) *MHL_VC_SEQUENCE_LENGTH == ucWriteBurstData[0]) // Number entry + (sequece -1) x length = total entry    {        bParsingFinish = TRUE;    }    for(uctemp = 0; uctemp <ucNumberEntry; uctemp++)    {        _mdrv_mhl_CheckVCInformation(ucWriteBurstData[uctemp *MHL_VC_SEQUENCE_LENGTH +3], ucWriteBurstData[uctemp *MHL_VC_SEQUENCE_LENGTH +4], ucWriteBurstData[uctemp *MHL_VC_SEQUENCE_LENGTH +5]);    }    if(bParsingFinish)    {        _mdrv_mhl_SortingVCInformation(TRUE);        _mdrv_mhl_eCbusTimeSlotAllocation();    }}//**************************************************************************//  [Function Name]://                  mdrv_mhl_ParsingWriteBurstBISTSetup()//  [Description]:////  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_ParsingWriteBurstBISTSetup(MS_U8 *ucWriteBurstData){    MS_U8 ucReadyIndex = 0x70;    MS_U8 ucBISTeCbusPattern = MhlDevCap_tbl[MHL_CBUS_ECBUS_SPEEDS];    MS_U8 ucBISTAVLinkRate = MhlDevCap_tbl[MHL_CBUS_TMDS_SPEEDS];    MS_U16 usBISTeCbusPatternFixed = 0;    MS_U16 usBISTAVLinkFixed = 0;    MS_U16 usBISTeCbusDuration = 0;    MS_U16 usBISTAVLinkDuration = 0;    if((ucBISTeCbusPattern &BIT(4)) == BIT(4)) // MHL_ECBUS_D_150    {        ucBISTeCbusPattern = MHL_BIST_ECBUS_PATTERN_FIXED10;    }    else if((ucBISTeCbusPattern &BIT(0)) == BIT(0)) // MHL_ECBUS_S_075    {        ucBISTeCbusPattern = MHL_BIST_ECBUS_PATTERN_FIXED8;    }    else    {        ucBISTeCbusPattern = MHL_BIST_ECBUS_PATTERN_PRBS;    }    if((ucBISTAVLinkRate & BIT(2)) == BIT(2)) // MHL_TMDS_600    {        ucBISTAVLinkRate = MHL_BIST_AV_LINK_600;    }    else if((ucBISTAVLinkRate & BIT(1)) == BIT(1)) // MHL_TMDS_300    {        ucBISTAVLinkRate = MHL_BIST_AV_LINK_300;    }    else if((ucBISTAVLinkRate & BIT(0)) == BIT(0)) // MHL_TMDS_150    {        ucBISTAVLinkRate = MHL_BIST_AV_LINK_150;    }    else    {        ucBISTAVLinkRate = MHL_BIST_AV_LINK_RESERVED;    }    if(ucWriteBurstData[1] <= ucBISTeCbusPattern) // Check eCbus pattern    {       ucReadyIndex = MASKSET(ucReadyIndex, BIT(0), (BIT(0) |BIT(4)));       ucBISTeCbusPattern = ucWriteBurstData[1];       usBISTeCbusPatternFixed = ((MS_U16)ucWriteBurstData[2] <<8) |ucWriteBurstData[3];    }    if(ucWriteBurstData[5] <= ucBISTAVLinkRate) // Check AV link rate    {        ucReadyIndex = MASKSET(ucReadyIndex, BIT(1), (BIT(1) |BIT(5)));        ucBISTAVLinkRate = ucWriteBurstData[5];        usBISTAVLinkFixed = ((MS_U16)ucWriteBurstData[9] <<8) |ucWriteBurstData[10];    }    if(ucWriteBurstData[0] == 0) // Check eCbus duration    {        // Can't allow    }    else    {        usBISTeCbusDuration = (MS_U16)ucWriteBurstData[0] *1010ul;    }    if(ucWriteBurstData[6] <= MHL_BIST_LINK_PATTERN_FIXED8)    {        usBISTAVLinkDuration = (MS_U16)ucWriteBurstData[7] *32 *(1000 /60);    }    else if(ucWriteBurstData[6] == MHL_BIST_LINK_PATTERN_FIXED10)    {        usBISTAVLinkDuration = (MS_U16)ucWriteBurstData[7] *1010ul;    }    SET_MHL_BIST_READY_INDEX(ucReadyIndex);    SET_MHL_BIST_ECBUS_PATTERN(ucBISTeCbusPattern);    SET_MHL_BIST_ECBUS_FIXED(usBISTeCbusPatternFixed);    SET_MHL_BIST_ECBUS_DURATION(usBISTeCbusDuration);    SET_MHL_BIST_AV_LINK_RATE(ucBISTAVLinkRate);    SET_MHL_BIST_AV_LINK_MODE(ucWriteBurstData[7]);    SET_MHL_BIST_AV_LINK_PATTERN(ucWriteBurstData[6]);    SET_MHL_BIST_AV_LINK_FIXED(usBISTAVLinkFixed);    SET_MHL_BIST_AV_LINK_DURATION(usBISTAVLinkDuration);    SET_MHL_BIST_AV_LINK_RANDOM(ucWriteBurstData[11]);    SET_MHL_BIST_IMPEDANCE_MODE(ucWriteBurstData[12]);}//**************************************************************************//  [Function Name]://                  mdrv_mhl_GetBISTReadyIndex()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_U8 mdrv_mhl_GetBISTReadyIndex(void){    return GET_MHL_BIST_READY_INDEX();}//**************************************************************************//  [Function Name]://                  mdrv_mhl_GetCbusTxQueueFreeze()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_U8 mdrv_mhl_GetCbusTxQueueFreeze(void){    return GET_MHL_CBUS_TX_QUEUE_FREEZE();}//**************************************************************************//  [Function Name]://                  mdrv_mhl_PowerResume()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_PowerResume(MS_BOOL bCableDetect, MS_BOOL bCbusConnect){    MS_U8 ucCbusSelect = GET_MHL_CBUS_SELECT_PATH();    if(bCableDetect)    {        if(bCbusConnect)        {            mhal_mhl_ClockModeSwitchProc(ucCbusSelect, FALSE);            mhal_mhl_CbusConnectProc(ucCbusSelect);            if(GET_MHL_INPUT_CLOCK_MODE() == CBUS_CLOCK_PACKET_PIXEL)            {                mhal_mhl_ClockModeSwitchProc(ucCbusSelect, TRUE);            }        }        else        {            mhal_mhl_CablePlugProc(ucCbusSelect);        }    }}//**************************************************************************//  [Function Name]://                  mdrv_mhl_CheckECbusStateNormal()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mdrv_mhl_CheckECbusStateNormal(void){    MS_BOOL bECbusNormal = FALSE;        if(GET_MHL_ECBUS_STATE() == MHL_ECBUS_STATE_STABLE_POLLING)    {        bECbusNormal = TRUE;    }    return bECbusNormal;}//**************************************************************************//  [Function Name]://                  _mdrv_mhl_SetMainLinkRate()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_SetMainLinkRate(MS_U8 ucLinkRate){    if(ucLinkRate < MHL_AV_LINK_NONE)    {        mhal_mhl_SetMainLinkRate(GET_MHL_CBUS_SELECT_PATH(), ucLinkRate);        mhal_mhl_CDRModeMonitor(GET_MHL_CBUS_SELECT_PATH(), FALSE);                msg_mhl(printf("** MHL set AV link rate mode %d port %c\r\n", ucLinkRate, MHL_INPUT_PORT(GET_MHL_CBUS_SELECT_PATH())));    }}//**************************************************************************//  [Function Name]://                  mdrv_mhl_ECbusStateHandler()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mdrv_mhl_ECbusStateHandler(void){    MS_BOOL bPollingFlag = FALSE;    MS_U8 ucECbusState = GET_MHL_ECBUS_STATE();    MS_U8 ucECbusEvent = MHL_ECBUS_EVENT_NONE;    MS_U8 ucECbusStatusFlag = mhal_mhl_GetECbusStatusFlag();    static MS_U16 ucECbusResetCounter = 0;        switch(ucECbusState)    {        case MHL_ECBUS_STATE_RECEIVE_MODE_UP:            SET_MHL_CBUS_TX_QUEUE_FREEZE();            ucECbusResetCounter = 0;            ucECbusEvent = MHL_ECBUS_EVENT_PREPARE_MODE_UP;            msg_mhl(printf("** MHL receive mode up !! port %c\r\n", MHL_INPUT_PORT(GET_MHL_CBUS_SELECT_PATH())));                        break;                    case MHL_ECBUS_STATE_TRIGGER_MODE_UP:            SET_MHL_ECBUS_STATE(MHL_ECBUS_STATE_PROCESS_MODE_UP);            ucECbusEvent = MHL_ECBUS_EVENT_MODE_UP_PROCESS;                          break;                    case MHL_ECBUS_STATE_PROCESS_MODE_UP:            if(ucECbusStatusFlag &MHL_ECBUS_STATUS_SLOT_SYNC_DONE)            {                CLR_MHL_CBUS_TX_QUEUE_FREEZE();                SET_MHL_ECBUS_STATE(MHL_ECBUS_STATE_MODE_UP_CLOCK_LOCK);                                msg_mhl(printf("** MHL Cbus1 command enable !! port %c\r\n", MHL_INPUT_PORT(GET_MHL_CBUS_SELECT_PATH())));            }            bPollingFlag = TRUE;            break;        case MHL_ECBUS_STATE_MODE_UP_CLOCK_LOCK:            if(ucECbusStatusFlag &MHL_ECBUS_STATUS_EMSC_SYNC_DONE)            {                SET_MHL_ECBUS_STATE(MHL_ECBUS_STATE_STABLE_POLLING);                                msg_mhl(printf("** MHL eMSC command enable !! port %c\r\n", MHL_INPUT_PORT(GET_MHL_CBUS_SELECT_PATH())));            }            bPollingFlag = TRUE;            break;                    case MHL_ECBUS_STATE_STABLE_POLLING:            bPollingFlag = TRUE;            break;        case MHL_ECBUS_STATE_TRIGGER_MODE_DOWN:            SET_MHL_ECBUS_STATE(MHL_ECBUS_STATE_PROCESS_MODE_DOWN);            break;        case MHL_ECBUS_STATE_PROCESS_MODE_DOWN:                        break;        default:            break;    };    if(bPollingFlag)    {        if((ucECbusStatusFlag &(MHL_ECBUS_STATUS_TRAINING_PASS| MHL_ECBUS_STATUS_CLOCK_LOCK)) == MHL_ECBUS_STATUS_TRAINING_PASS)        {            SET_MHL_CBUS_TX_QUEUE_FREEZE();            SET_MHL_ECBUS_STATE(MHL_ECBUS_STATE_PROCESS_MODE_UP);            ucECbusEvent = MHL_ECBUS_EVENT_UNLOCK_RESET;            msg_mhl(printf("** MHL uclock reset ECbus !! port %c\r\n", MHL_INPUT_PORT(GET_MHL_CBUS_SELECT_PATH())));        }        else if((ucECbusStatusFlag &(MHL_ECBUS_STATUS_TRAINING_PASS| MHL_ECBUS_STATUS_CLOCK_LOCK)) == 0)        {            ucECbusResetCounter++;        }        else if((ucECbusStatusFlag &(MHL_ECBUS_STATUS_TRAINING_PASS| MHL_ECBUS_STATUS_CLOCK_LOCK)) == MHL_ECBUS_STATUS_CLOCK_LOCK)        {            ucECbusResetCounter++;        }        else        {            ucECbusResetCounter = 0;        }        if(ucECbusResetCounter == 1000)        {            SET_MHL_ECBUS_STATE(MHL_ECBUS_STATE_NONE);            //ucECbusEvent = MHL_ECBUS_EVENT_STUCK_TO_LOW;        }    }    mhal_mhl_ECbusEventProc(GET_MHL_CBUS_SELECT_PATH(), ucECbusEvent);    if((ucECbusState >= MHL_ECBUS_STATE_RECEIVE_MODE_UP) && (ucECbusState < MHL_ECBUS_STATE_TRIGGER_MODE_UP))    {        ucECbusState++;        SET_MHL_ECBUS_STATE(ucECbusState);    }    else if((ucECbusState >= MHL_ECBUS_STATE_RECEIVE_MODE_DOWN) && (ucECbusState < MHL_ECBUS_STATE_TRIGGER_MODE_DOWN))    {        ucECbusState++;                SET_MHL_ECBUS_STATE(ucECbusState);    }}// config HPD in combo(MHL/HDMI) port Cvoid mdrv_mhl_SetHPD(MS_BOOL bflag){    mhal_mhl_SetHPD(bflag);}// MHL power control//E_MHL_POWER_ONvoid mdrv_mhl_PowerOn(void){    mhal_mhl_LoadPowerOnTbl();}//E_MHL_POWER_STANDBYvoid mdrv_mhl_PowerStandby(MS_BOOL bFlag){    mhal_mhl_LoadPowerStandbyTbl();}//E_MHL_POWER_DOWNvoid mdrv_mhl_PowerDown(void){    mhal_mhl_LoadPowerDownTbl();}#endif // _MDRV_MHL_C_