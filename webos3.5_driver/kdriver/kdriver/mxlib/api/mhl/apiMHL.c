//<MStar Software>//******************************************************************************// MStar Software// Copyright (c) 2010 - 2012 MStar Semiconductor, Inc. All rights reserved.// All software, firmware and related documentation herein ("MStar Software") are// intellectual property of MStar Semiconductor, Inc. ("MStar") and protected by// law, including, but not limited to, copyright law and international treaties.// Any use, modification, reproduction, retransmission, or republication of all// or part of MStar Software is expressly prohibited, unless prior written// permission has been granted by MStar.//// By accessing, browsing and/or using MStar Software, you acknowledge that you// have read, understood, and agree, to be bound by below terms ("Terms") and to// comply with all applicable laws and regulations://// 1. MStar shall retain any and all right, ownership and interest to MStar//    Software and any modification/derivatives thereof.//    No right, ownership, or interest to MStar Software and any//    modification/derivatives thereof is transferred to you under Terms.//// 2. You understand that MStar Software might include, incorporate or be//    supplied together with third party`s software and the use of MStar//    Software may require additional licenses from third parties.//    Therefore, you hereby agree it is your sole responsibility to separately//    obtain any and all third party right and license necessary for your use of//    such third party`s software.//// 3. MStar Software and any modification/derivatives thereof shall be deemed as//    MStar`s confidential information and you agree to keep MStar`s//    confidential information in strictest confidence and not disclose to any//    third party.//// 4. MStar Software is provided on an "AS IS" basis without warranties of any//    kind. Any warranties are hereby expressly disclaimed by MStar, including//    without limitation, any warranties of merchantability, non-infringement of//    intellectual property rights, fitness for a particular purpose, error free//    and in conformity with any international standard.  You agree to waive any//    claim against MStar for any loss, damage, cost or expense that you may//    incur related to your use of MStar Software.//    In no event shall MStar be liable for any direct, indirect, incidental or//    consequential damages, including without limitation, lost of profit or//    revenues, lost or damage of data, and unauthorized system use.//    You agree that this Section 4 shall still apply without being affected//    even if MStar Software has been modified by MStar in accordance with your//    request or instruction for your use, except otherwise agreed by both//    parties in writing.//// 5. If requested, MStar may from time to time provide technical supports or//    services in relation with MStar Software to you for your use of//    MStar Software in conjunction with your or your customer`s product//    ("Services").//    You understand and agree that, except otherwise agreed by both parties in//    writing, Services are provided on an "AS IS" basis and the warranty//    disclaimer set forth in Section 4 above shall apply.//// 6. Nothing contained herein shall be construed as by implication, estoppels//    or otherwise://    (a) conferring any license or right to use MStar name, trademark, service//        mark, symbol or any other identification;//    (b) obligating MStar or any of its affiliates to furnish any person,//        including without limitation, you and your customers, any assistance//        of any kind whatsoever, or any information; or//    (c) conferring any license or right under any intellectual property right.//// 7. These terms shall be governed by and construed in accordance with the laws//    of Taiwan, R.O.C., excluding its conflict of law rules.//    Any and all dispute arising out hereof or related hereto shall be finally//    settled by arbitration referred to the Chinese Arbitration Association,//    Taipei in accordance with the ROC Arbitration Law and the Arbitration//    Rules of the Association by three (3) arbitrators appointed in accordance//    with the said Rules.//    The place of arbitration shall be in Taipei, Taiwan and the language shall//    be English.//    The arbitration award shall be final and binding to both parties.////******************************************************************************//<MStar Software>///////////////////////////////////////////////////////////////////////////////////////////////////////// file    apiMHL.c/// @author MStar Semiconductor Inc./// @brief  MHL driver Function///////////////////////////////////////////////////////////////////////////////////////////////////#ifndef _API_MHL_C_#define _API_MHL_C_//-------------------------------------------------------------------------------------------------//  Include Files//-------------------------------------------------------------------------------------------------// Common Definition#include "MsCommon.h"#include "MsVersion.h"#ifdef MSOS_TYPE_LINUX_KERNEL#include <linux/string.h>#else#include <string.h>#endif#include "mdrv_mhl_st.h"#include "apiMHL.h"#include "halMHL.h"#include "drvMHL.h"//-------------------------------------------------------------------------------------------------//  Local Defines//-------------------------------------------------------------------------------------------------#define msg_mhl(x) x#define MAPI_SUPPORT_MHL        1//-------------------------------------------------------------------------------------------------//  Local Structures//-------------------------------------------------------------------------------------------------MHLInfo_S gMHLInfo = {0};MS_U8 ucMHLWriteBurstInformation[MHL_MSC_SCRATCHPAD_SIZE +2];//-------------------------------------------------------------------------------------------------//  Global Variables//-------------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------------//  Local Variables//-------------------------------------------------------------------------------------------------static link_cbus_event_handle_func pfnMapi_mhl_CbusRcpProcess = NULL;static link_cbus_event_handle_func pfnMapi_mhl_CbusRapProcess = NULL;static link_cbus_event_handle_func pfnMapi_mhl_CbusUcpProcess = NULL;static link_cbus_event_handle_func pfnMapi_mhl_CbusAttProcess = NULL;static link_cbus_event_handle_func pfnMapi_mhl_CbusRbpProcess = NULL;static MS_BOOL bIsMHLEnable = FALSE;//-------------------------------------------------------------------------------------------------//  Local Functions//-------------------------------------------------------------------------------------------------//**************************************************************************//  [Function Name]://                  _mapi_mhl_CableDetect()//  [Description]//                  MHL cable detection//  [Arguments]:////  [Return]://                  TRUE: MHL cable plugged//                  FALSE: MHL cable unplugged//**************************************************************************MS_BOOL _mapi_mhl_CableDetect(MS_U8 ucPort){    static MS_BOOL bPreCableDetect = FALSE;    MS_BOOL bFlag = mdrv_mhl_CableDetect(); // Cable detect of current Cbus select    if(mdrv_mhl_CheckInputCbusSelect(ucPort)) // Cbus select mux change    {        bFlag = FALSE;    }    if(bFlag)    {        if(!GET_MHL_CABLE_PLUGGED())        {#if(MHL_CBUS_OPERATION_MODE == MHL_CBUS_SW_ISR_MODE ||MHL_CBUS_OPERATION_MODE == MHL_CBUS_HW_ISR_MODE)            //MsOS_EnableInterrupt(E_INT_IRQ_MHL_CBUS_PM);#endif            SET_MHL_DEBOUNCE_TIMER(CBUS_SWITCH_MUX_TIME_MS);            SET_MHL_CABLE_PLUGGED();        }        bPreCableDetect = TRUE;    }    else    {        if(GET_MHL_CABLE_PLUGGED() ||(!GET_MHL_PORT_ON_FLAG()))        {            gMHLInfo.MhlCbusInfo.curIdx = 0;            SET_MHL_CBUS_STATE(CBUS_STATE_IDLE);            SET_MHL_CBUS_ERROE_CODE(MSC_ERRORCODE_NO_ERROR);            CLR_MHL_PLUGGED_FLAG();#if(MHL_CBUS_OPERATION_MODE == MHL_CBUS_SW_ISR_MODE ||MHL_CBUS_OPERATION_MODE == MHL_CBUS_HW_ISR_MODE)            //MsOS_DisableInterrupt(E_INT_IRQ_MHL_CBUS_PM);#endif        }    }    if(GET_MHL_PORT_SELECT() != ucPort)    {        if(bPreCableDetect)        {            if(bFlag || (bPreCableDetect ^ mdrv_mhl_CheckInputPort()))            {                mdrv_mhl_SourceChangeProc(ucPort);            }            bPreCableDetect = FALSE;        }        SET_MHL_PORT_SELECT(ucPort);    }    if(!GET_MHL_PORT_ON_FLAG())    {        mdrv_mhl_CbusConfigControl(FALSE);        SET_MHL_PORT_ON_FLAG();    }    return GET_MHL_CABLE_PLUGGED();}//**************************************************************************//  [Function Name]:mapi_mhl_FunctionSwitch()////  [Description]: Disable or enable MHL////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mapi_mhl_IsFunctionEnable(void ){    return  bIsMHLEnable;}MS_BOOL mapi_mhl_Set_MHL_ON_OFF(MS_BOOL bMHLEnable ){  if(bMHLEnable)  {      bIsMHLEnable = TRUE;  }  else  {      bIsMHLEnable = FALSE;  }  return TRUE;}void mapi_mhl_FunctionSwitch(MS_BOOL bMHLEnable ){    if(bMHLEnable == FALSE)    {        mdrv_mhl_CbusControl(MHL_CBUS_ISOLATION_ON);    }    else    {        mdrv_mhl_CbusControl(MHL_CBUS_ISOLATION_OFF);    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_SetControlTimer()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_SetControlTimer(MS_U8 ucTime){    if(ucTime == 0)    {        CLR_MHL_TIME_OUT_FLAG();    }    else    {        SET_MHL_TIME_OUT_FLAG();    }#if(DMHL_TIMER_POLLING_INTERVAL)    SET_MHL_DEBOUNCE_TIMER(ucTime *CBUS_TIMER_SECOND_COUNT);#else    SET_MHL_TIMEOUT_TIMER(ucTime);#endif}//**************************************************************************//  [Function Name]://                  _mapi_mhl_SetPowerOnTimer()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_SetPowerOnTimer(MS_U8 ucTime){    static MS_U8 ucCounter = 0;    if(ucTime == 0)    {        if(ucCounter > 0)        {            ucCounter--;        }        else if(GET_MHL_POWER_ON_TIMER())        {            CLR_MHL_POWER_ON_TIMER();        }    }    else    {        ucCounter = ucTime;        SET_MHL_POWER_ON_TIMER();    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_SetReceiveLoseTime()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_SetReceiveLoseTime(MS_U8 ucTime){    static MS_U8 ucCounter = 0;    if(ucTime == 0)    {        if(ucCounter > 0)        {            ucCounter--;        }        else if(GET_MHL_RECEIVE_LOSE_FLAG())        {            if(GET_MHL_RX_RECEIVE_COUNTER() == 0)            {                INC_MHL_RX_RECEIVE_COUNTER();            }            CLR_MHL_RECEIVE_LOSE_FLAG();        }    }    else    {        ucCounter = ucTime;        SET_MHL_RECEIVE_LOSE_FLAG();    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_SetMSGWaitReplyTime()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_SetMSGWaitReplyTime(MS_U8 ucTime){    static MS_U8 ucCounter = 0;    if(ucTime == 0)    {        if(ucCounter > 0)        {            ucCounter--;        }        else if(GET_MHL_SEND_MSG_COMMAND())        {            CLR_MHL_SEND_MSG_COMMAND();        }    }    else    {        ucCounter = ucTime;        SET_MHL_SEND_MSG_COMMAND();    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_SetRCPReleaseSendTime()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_SetRCPReleaseSendTime(MS_U8 ucTime, MS_U8 ucKeyCode){    MS_BOOL bSendReleaseFlag = FALSE;    static MS_U8 ucCounter = 0;    static MS_U8 ucPreKeyCode = RCP_KEYID_SELECT_RELEASE;    if(ucTime == 0)    {        if(ucCounter > 0)        {            ucCounter--;        }        else        {            bSendReleaseFlag = GET_MHL_SEND_RCP_RELEASE_FLAG();        }    }    else    {        if((ucCounter != 0) && (ucPreKeyCode != ucKeyCode))        {            bSendReleaseFlag = GET_MHL_SEND_RCP_RELEASE_FLAG();        }        else        {            ucCounter = ucTime;            ucPreKeyCode = ucKeyCode;            SET_MHL_SEND_RCP_RELEASE_FLAG();        }    }    if(bSendReleaseFlag)    {        ucKeyCode = ucPreKeyCode |BIT(7);        if(mapi_mhl_SendRCPCmd(ucKeyCode))        {            CLR_MHL_SEND_RCP_RELEASE_FLAG();            msg_mhl(printf("** MHL send RCP release key code 0x%x port %c\r\n", ucKeyCode, MHL_INPUT_PORT(mdrv_mhl_GetCbusPath())));        }    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_SetCheckContentOnTime()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_SetCheckContentOnTime(MS_U8 ucTime){    static MS_U8 ucCounter = 0;    if(ucTime == 0)    {        if(ucCounter > 0)        {            ucCounter--;        }        else if(GET_MHL_SEND_CHECK_CONTENT_ON())        {            CLR_MHL_SEND_CHECK_CONTENT_ON();        }    }    else    {        ucCounter = ucTime;        SET_MHL_SEND_CHECK_CONTENT_ON();        SET_MHL_PATH_EN_FLAG();    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_InsertCbusMSGInformation(MS_U8 cmd)//  [Description]://                  MHL Cbus process MSC sub command//  [Arguments]://                  cmd: command//                  databuf: data//  [Return]:////**************************************************************************MS_BOOL _mapi_mhl_InsertCbusMSGInformation(MS_U8 ucCmd, MS_U8 ucData){    MS_BOOL bIndex = TRUE;    SET_MHL_CBUS_STATE(CBUS_STATE_RECEIVED);    SET_MHL_RX_MSG_COMMAND(ucCmd);    SET_MHL_RX_MSG_DATA(ucData);    SET_MHL_RECEIVE_MSG();    return bIndex;}//**************************************************************************//  [Function Name]://                  _mapi_mhl_InsertCbusAskData()//  [Description]:////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_InsertCbusAskData(MS_U8 ucReceiveMSC){    if(GET_MHL_SEND_ASK_DATA())    {        CLR_MHL_SEND_ASK_DATA();        SET_MHL_SEND_ASK_FINISH();        SET_MHL_CBUS_ASK_DATA(ucReceiveMSC);    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_ParsingWriteBurstInformation()//  [Description]:////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_ParsingWriteBurstInformation(MS_U8 *ucWriteBurstData){    MS_U8 uctemp = 0;    MS_U8 ucCheckSum = 0;    MS_U16 usWriteBurstID = ((MS_U16)ucWriteBurstData[0] <<8) |ucWriteBurstData[1];    for(uctemp = 0; uctemp <MHL_MSC_SCRATCHPAD_SIZE; uctemp++)    {        ucCheckSum = ucCheckSum +ucWriteBurstData[uctemp];    }    if(ucCheckSum == 0)    {        switch(usWriteBurstID)        {            case MHL_BURST_ID_VC_ASSIGN:                if(mdrv_mhl_ParsingWriteBurstVCAssign(&ucWriteBurstData[3]))                {                    SET_MHL_RECEIVE_VC_ASSIGN();                }                break;            case MHL_BURST_ID_VC_CONFIRM:                mdrv_mhl_ParsingWriteBurstVCConfirm(&ucWriteBurstData[3]);                break;            case MHL_BURST_ID_BIST_SETUP:                SET_MHL_BIST_PROCESS_STATE(MHL_CBUS_BIST_RECEIVE_SETUP);                mdrv_mhl_ParsingWriteBurstBISTSetup(&ucWriteBurstData[3]);                break;            default:                break;        };    }    else    {        msg_mhl(printf("** MHL write burst check sum error port %c\r\n", MHL_INPUT_PORT(mdrv_mhl_GetCbusPath())));    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusIntHandler()//  [Description]//                  MHL Cbus Interrupt Handler//  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_CbusIntHandler(void){    MS_BOOL bretAck = TRUE;    MS_BOOL ucCount = 0;#if(MHL_CBUS_OPERATION_MODE == MHL_CBUS_HW_ISR_MODE || MHL_CBUS_OPERATION_MODE == MHL_CBUS_HW_REPLY_MODE)    switch(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).cmd)    {        case MSC_ACK:            SET_MHL_RECEIVE_ACK();            if(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).len > 0)            {                _mapi_mhl_InsertCbusAskData(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[0]);            }            break;        case MSC_ABORT: // wait 2 sec before starting a new Cbus transaction after receiving an ABORT, Chapter 13.10.3            SET_MHL_RECEIVE_ABORT();            break;        case MSC_GET_DDC_ERRORCODE:            mdrv_mhl_GetDDCErrorCode();            break;        case MSC_MSC_MSG:            bretAck = _mapi_mhl_InsertCbusMSGInformation(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[0], GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[1]);            break;        case MSC_WRITE_STAT_OR_SET_INT:            if(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[0] == 0x31) // Extended device capability support            {                mdrv_mhl_ClockModeSwitch(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[1] &(BIT(2) |BIT(1) |BIT(0)));                if((GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[1] &BIT(3)) == BIT(3)) // Path en                {                    SET_MHL_RECEIVE_PATH_EN();                }                if((GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[1] &BIT(4)) == BIT(4)) // Muted                {                    SET_MHL_RECEIVE_MUTED();                }            }            if(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[0] == 0x30)            {                if((GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[1] &BIT(0)) == BIT(0)) // Devcap ready                {                    SET_MHL_RECEIVE_DEVCAP();                }                if((GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[1] &BIT(1)) == BIT(1)) // Extended device capability support                {                    SET_MHL_RECEIVE_XDEVCAP();                }            }            if((GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[0] == 0x32) && (GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[1] >= 0x30)) // Source support MHL3            {                SET_MHL_RECEIVE_MHL3_VERSION();            }            if(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[0] == 0x20)            {                if((GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[1] &BIT(0)) == BIT(0)) // Devcap change                {                    SET_MHL_RECEIVE_DEVCAP();                }                if((GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[1] &BIT(1)) == BIT(1)) // Scratchpad register change                {                    SET_MHL_WRITE_BURST_STATE(MHL_CBUS_WRITE_BURST_END);                }                if((GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[1] &BIT(3)) == BIT(3)) // Burst write grant                {                    if(GET_MHL_WRITE_BURST_STATE() == MHL_CBUS_WRITE_BURST_SEND_REQUEST)                    {                        SET_MHL_WRITE_BURST_STATE(MHL_CBUS_WRITE_BURST_REVEIVE_GRANT);                    }                }                if((GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[1] &BIT(4)) == BIT(4)) // 3D request                {                    SET_MHL_RECEIVE_3D_REQUEST();                }                if((GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[1] &BIT(5)) == BIT(5)) // Feature request                {                    SET_MHL_RECEIVE_FEATURE_REQUEST();                }                if((GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[1] &BIT(6)) == BIT(6)) // Feature complete                {                    SET_MHL_RECEIVE_FEATURE_COMPLETE();                }            }                        break;        case MSC_WRITE_XSTAT:            if(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[0] == 0x92)            {                SET_MHL_RECEIVE_LINK_RATE();                SET_MHL_LINK_RATE(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[1]);            }                        break;        case MSC_WRITE_BURST:            SET_MHL_WRITE_BURST_ADDRESS(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[0]);            SET_MHL_WRITE_BURST_LENGTH(MHL_MSC_SCRATCHPAD_SIZE +1);            for(ucCount = 0; ucCount < (MHL_MSC_SCRATCHPAD_SIZE +1); ucCount++)            {                if(ucCount < GET_MHL_WRITE_BURST_LENGTH())                {                    if(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[ucCount +1] == MSC_EOF)                    {                        SET_MHL_WRITE_BURST_DATA(ucCount, 0);                        SET_MHL_WRITE_BURST_LENGTH(ucCount -1);                    }                    else                    {                        SET_MHL_WRITE_BURST_DATA(ucCount, GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[ucCount +1]);                    }                }                else if(ucCount < MHL_MSC_SCRATCHPAD_SIZE)                {                    SET_MHL_WRITE_BURST_DATA(ucCount, 0);                }            }            _mapi_mhl_ParsingWriteBurstInformation(&GET_MHL_WRITE_BURST_DATA(0));                        break;                    case MSC_RESERVED:                        break;                    default:                        break;    };    #else    if(GET_MHL_CBUS_STATE() == CBUS_STATE_RECEIVED) // received valid message    {        // Begin processing received packet, set Cbus state idle and free queue        SET_MHL_QUEUE_STATE(MHL_CBUS_RX_QUEUE_INDEX, CBUS_REQ_IDLE);        SET_MHL_CBUS_STATE(CBUS_STATE_IDLE);        if(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).rcState == CBUS_RECEIVE_NORMAL) // received normally        {            switch(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).cmd)            {                case MSC_ACK:                    SET_MHL_CBUS_STATE(CBUS_STATE_ACK);                    break;                case MSC_NACK:                    break;                case MSC_ABORT: // wait 2 sec before starting a new Cbus transaction after receiving an ABORT, Chapter 13.10.3                    SET_MHL_RECEIVE_ABORT();                    break;                case MSC_WRITE_STAT_OR_SET_INT:            #if DMHL_CTS                    // CTS 6.3.11.8 && 6.3.11.11                    if(gMHLInfo.MhlCbusInfo.bIsCmdinDataField)                    {                        SET_MHL_CBUS_ERROE_CODE(MSC_ERRORCODE_PROTOCOL_ERROR);                        bretAck = FALSE;                        SET_MHL_RECEIVE_ERROR();                    }                    else                    {                        if(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[0] == 0x31)                        {                            mdrv_mhl_ClockModeSwitch(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[1] &(BIT(2) |BIT(1) |BIT(0)));                        }                        if((GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[0] == 0x30) && (GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[1] == 0x01)) // Devcap ready                        {                            SET_MHL_RECEIVE_DEVCAP();                        }                        if(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[0] == 0x20)                        {                            if((GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[1] &BIT(0)) == BIT(0)) // Devcap change                            {                                SET_MHL_RECEIVE_DEVCAP();                            }                            if((GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[1] &BIT(3)) == BIT(3)) // Burst write grant                            {                                if(GET_MHL_WRITE_BURST_STATE() == MHL_CBUS_WRITE_BURST_SEND_REQUEST)                                {                                    SET_MHL_WRITE_BURST_STATE(MHL_CBUS_WRITE_BURST_REVEIVE_GRANT);                                }                            }                            if((GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[1] &BIT(4)) == BIT(4)) // 3D request                            {                                SET_MHL_RECEIVE_3D_REQUEST();                            }                        }                    }            #endif                    mdrv_mhl_CbusReply(bretAck ? MSC_ACK : MSC_ABORT, FALSE, 0);                    break;                case MSC_READ_DEVCAP:                    // HW auto reply, REG_MHL_CBUS_23[10] = 1            #if DMHL_CTS                    // CTS 6.3.11.8                    if(gMHLInfo.MhlCbusInfo.bIsCmdinDataField)                    {                        mdrv_mhl_CbusReply(MSC_ABORT, FALSE, 0);                        SET_MHL_RECEIVE_ERROR();                        SET_MHL_CBUS_ERROE_CODE(MSC_ERRORCODE_PROTOCOL_ERROR);                    }                    else                    {                        // CTS 6.3.11.9                        if(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[0] <= 0x0F)                        {                            mdrv_mhl_CbusReply(MSC_ACK, TRUE, mdrv_mhl_GetDevCap(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[0]));                            SET_MHL_CBUS_ERROE_CODE(MSC_ERRORCODE_NO_ERROR);                        }                        else                        {                            mdrv_mhl_CbusReply(MSC_ABORT, FALSE, 0);                            SET_MHL_RECEIVE_ERROR();                            SET_MHL_CBUS_ERROE_CODE(MSC_ERRORCODE_BAD_OFFSET);                        }                    }           #else                    mdrv_mhl_CbusReply(MSC_ACK, TRUE, mdrv_mhl_GetDevCap(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[0]));           #endif // #if DMHL_CTS                    break;                case MSC_GET_STATE:                    mdrv_mhl_CbusReply(MSC_GET_STATE, TRUE, mdrv_mhl_GetDevCap(0)); // DevCap register 0x00                    break;                case MSC_GET_VENDOR_ID:                    mdrv_mhl_CbusReply(MSC_GET_VENDOR_ID, TRUE, mdrv_mhl_GetVenderID());                    break;                case MSC_MSC_MSG:            #if DMHL_CTS                    // CTS 6.3.11.22 & 6.3.11.24                    if(gMHLInfo.MhlCbusInfo.bIsCmdinDataField)                    {                        SET_MHL_CBUS_ERROE_CODE(MSC_ERRORCODE_PROTOCOL_ERROR);                        bretAck = FALSE;                        SET_MHL_RECEIVE_ERROR();                    }                    else                    {                        bretAck = _mapi_mhl_InsertCbusMSGInformation(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[0], GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[1]);                        // HW auto reply, REG_MHL_CBUS_23[9:8] = 2'b11                    }            #endif // #if DMHL_CTS                    mdrv_mhl_CbusReply(bretAck ? MSC_ACK : MSC_ABORT, FALSE, 0);                    break;                case MSC_WRITE_BURST:            #if DMHL_CTS                    // CTS 6.3.11.20                    if(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[0] + (GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).len -2) > (0x40 + MHL_MSC_SCRATCHPAD_SIZE))                    {                        SET_MHL_CBUS_ERROE_CODE(MSC_ERRORCODE_BAD_OFFSET);                        bretAck = FALSE;                        SET_MHL_RECEIVE_ERROR();                    }                    // CTS 6.3.11.14                    if(gMHLInfo.MhlCbusInfo.bIsCmdinDataField)                    {                        SET_MHL_CBUS_ERROE_CODE(MSC_ERRORCODE_PROTOCOL_ERROR);                        bretAck = FALSE;                        SET_MHL_RECEIVE_ERROR();                    }                    if(bretAck)                    {                        SET_MHL_WRITE_BURST_ADDRESS(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[0]);                        SET_MHL_WRITE_BURST_LENGTH(MHL_MSC_SCRATCHPAD_SIZE +1);                        for(ucCount = 0; ucCount < (MHL_MSC_SCRATCHPAD_SIZE +1); ucCount++)                        {                            if(ucCount < GET_MHL_WRITE_BURST_LENGTH())                            {                                if(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[ucCount +1] == MSC_EOF)                                {                                    SET_MHL_WRITE_BURST_DATA(ucCount, 0);                                    SET_MHL_WRITE_BURST_LENGTH(ucCount -1);                                }                                else                                {                                    SET_MHL_WRITE_BURST_DATA(ucCount, GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[ucCount +1]);                                }                            }                            else if(ucCount < MHL_MSC_SCRATCHPAD_SIZE)                            {                                SET_MHL_WRITE_BURST_DATA(ucCount, 0);                            }                        }                    }            #endif // #if DMHL_CTS                    mdrv_mhl_CbusReply(bretAck ? MSC_ACK : MSC_ABORT, FALSE, 0);                    break;                case MSC_GET_MSC_ERRORCODE:                    mdrv_mhl_CbusReply(MSC_GET_MSC_ERRORCODE, TRUE, GET_MHL_CBUS_ERROE_CODE());                    break;                case MSC_GET_DDC_ERRORCODE:                    mdrv_mhl_CbusReply(MSC_GET_DDC_ERRORCODE, TRUE, mdrv_mhl_GetDDCErrorCode());                    break;                case MSC_GET_SC1_ERRORCODE:                case MSC_GET_SC3_ERRORCODE:                    // CTS 6.3.11.1                    SET_MHL_CBUS_ERROE_CODE(MSC_ERRORCODE_BAD_OFFSET);                    //mdrv_mhl_CbusReply(MSC_ACK, TRUE, MSC_ERRORCODE_NO_ERROR);                    break;                case MSC_EOF:                    break;                // CTS 6.3.16.1 ~ 6.3.16.2                case MSC_SET_HPD:                case MSC_CLR_HPD:                    mdrv_mhl_CbusReply(MSC_ABORT, FALSE, 0);                    SET_MHL_RECEIVE_ERROR();                    SET_MHL_CBUS_ERROE_CODE(MSC_ERRORCODE_INVALID_OPCODE);                    break;                default:                    // CTS 6.3.6.2 & 6.3.11.2                    mdrv_mhl_CbusReply(MSC_ABORT, FALSE, 0);                    SET_MHL_RECEIVE_ERROR();                    SET_MHL_CBUS_ERROE_CODE(MSC_ERRORCODE_INVALID_OPCODE);                    break;            }        }        else // received message is not valid        {            msg_mhl(printf("**Unknow: 0x%x \r\n", GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).cmd));        }    }#endif	bretAck = bretAck;}#if(MHL_CBUS_OPERATION_MODE == MHL_CBUS_HW_REPLY_MODE)//**************************************************************************//  [Function Name]://                  _mapi_mhl_RxSRAMHandler()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL _mapi_mhl_RxSRAMHandler(void){    MS_BOOL bFlag = FALSE;    MS_U8 uctemp = 0;    MS_U16 usLength = 0;    MS_U16 usValue = 0;    usLength = (mdrv_mhl_GetSRAMReceiveData()) &BMASK(6:0); // Get MSC command length    if(usLength > 0)    {        usValue = mdrv_mhl_GetSRAMReceiveData(); // Get MSC command        if(usValue &BIT(8))        {            GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).cmd = usValue &BMASK(7:0);        }        else        {            _mapi_mhl_InsertCbusAskData(usValue &BMASK(7:0));            GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).cmd = MSC_ACK;        }        for(uctemp = 0; uctemp < (usLength -2); uctemp++)        {            usValue = mdrv_mhl_GetSRAMReceiveData(); // Get MSC data            if((usValue &BIT(8)) == BIT(8)) // Command in data error happen            {                // For CTS 6.3.6.5 entry 4                if((usValue &BMASK(7:0)) == MSC_ABORT)                {                    GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).cmd = usValue &BMASK(7:0);                }                else if((usValue &BMASK(7:0)) == MSC_EOF)                {                    // EOF is command but it is not error                    GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[uctemp] = usValue &BMASK(7:0);                }            }            else            {                GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[uctemp] = usValue &BMASK(7:0);            }        }        GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).len = usLength -2;        bFlag = TRUE;    }    return bFlag;}#endif//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusIntCB()//  [Description]//                  MHL Cbus Interrupt Call Back function//  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_CbusIntCB(void){    MS_BOOL bflag;#if(MHL_CBUS_OPERATION_MODE == MHL_CBUS_HW_ISR_MODE)    CbusReq_S preq;    // Read received Cbus packet from register    if(mdrv_mhl_CbusIntCB(&preq, &bflag))    {        _mapi_mhl_InsertCbusAskData(preq.cmd);        preq.cmd = MSC_ACK; // Change command to ACK for clear Tx queue    }    if(bflag)   // Command in data error happen    {        // For CTS 6.3.6.5 entry 4        if(preq.msgData[0] == MSC_ABORT)        {            preq.cmd = preq.msgData[0];        }    }    preq.reqStatus = GET_MHL_QUEUE_STATE(MHL_CBUS_RX_QUEUE_INDEX);    memcpy(&(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX)), &preq, sizeof(CbusReq_S));    SET_MHL_CBUS_STATE(CBUS_STATE_IDLE);    DEC_MHL_RX_RECEIVE_COUNTER();    //SET_MHL_QUEUE_STATE(MHL_CBUS_RX_QUEUE_INDEX, CBUS_REQ_IDLE);#elif(MHL_CBUS_OPERATION_MODE == MHL_CBUS_HW_REPLY_MODE)    MS_U8 ucReceiveCount = 0;    if(mdrv_mhl_CheckSRAMReceiveBuffer()) // received valid message    {        ucReceiveCount = GET_MHL_RX_RECEIVE_COUNTER();        if(ucReceiveCount > 0)        {            for( ; ucReceiveCount > 0; ucReceiveCount--)            {                bflag = _mapi_mhl_RxSRAMHandler();                if(bflag)                {                    _mapi_mhl_CbusIntHandler();                    DEC_MHL_RX_RECEIVE_COUNTER();                }            }        }        else if(!GET_MHL_RECEIVE_LOSE_FLAG())        {            _mapi_mhl_SetReceiveLoseTime(2);        }        SET_MHL_CBUS_STATE(CBUS_STATE_IDLE);    }#else    CbusReq_S preq;    if(GET_MHL_RECEIVE_MSC() || mdrv_mhl_CbusIsMscMsgReceived()) // received valid message    {        SET_MHL_RECEIVE_MSC();        // Read received Cbus packet from register        if(mdrv_mhl_CbusIntCB(&preq, &bflag))        {            if(GET_MHL_CBUS_QUEUE(gMHLInfo.MhlCbusInfo.curIdx).cmd == MSC_GET_VENDOR_ID)            {                _mapi_mhl_InsertCbusAskData(preq.cmd);                preq.cmd = MSC_ACK; // Change command to ACK for clear Tx queue            }        }#if DMHL_CTS        // CTS 6.3.10.5        #if 0        if((preq.cmd != MSC_GET_MSC_ERRORCODE) && (preq.rcState == 0))        {            SET_MHL_CBUS_ERROE_CODE(MSC_ERRORCODE_NO_ERROR)        }        #endif        // CTS 6.3.12.1 ~ 6.3.12.9        if(preq.rcState == CBUS_RECEIVE_TIMEOUT)        {            SET_MHL_CBUS_ERROE_CODE(MSC_ERRORCODE_PEER_TIMEOUT);        }        // CTS 6.3.11.4 ~ 6.3.11.7        if((GET_MHL_CBUS_STATE() != CBUS_STATE_SENT) &&            ((preq.cmd == MSC_ACK) || (preq.cmd == MSC_NACK) || (preq.cmd == MSC_ABORT) ||(preq.cmd == MSC_EOF)))        {            SET_MHL_CBUS_ERROE_CODE(MSC_ERRORCODE_INVALID_OPCODE);            if((preq.cmd != MSC_ABORT))            {                mdrv_mhl_CbusReply(MSC_ABORT, FALSE, 0);                SET_MHL_RECEIVE_ERROR();            }        }#endif        if((preq.cmd != MSC_ACK) && (preq.cmd != MSC_NACK) && (preq.cmd != MSC_ABORT))        {            memcpy(&(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX)), &preq, sizeof(CbusReq_S));            gMHLInfo.MhlCbusInfo.bIsCmdinDataField = bflag;            switch(GET_MHL_CBUS_STATE())            {                case CBUS_STATE_IDLE:                case CBUS_STATE_SENT:                    SET_MHL_QUEUE_STATE(MHL_CBUS_RX_QUEUE_INDEX, CBUS_REQ_RECEIVED);                    SET_MHL_CBUS_STATE(CBUS_STATE_RECEIVED);                    break;                default:                    SET_MHL_CBUS_STATE(CBUS_STATE_IDLE);                    break;            }        }        else        {#if DMHL_CTS            // CTS 6.3.6.3            if((GET_MHL_CBUS_STATE() == CBUS_STATE_SENT) && ((preq.cmd == MSC_ACK) && bflag))            {                mdrv_mhl_CbusReply(MSC_ABORT, FALSE, 0);                SET_MHL_RECEIVE_ERROR();                SET_MHL_CBUS_ERROE_CODE(MSC_ERRORCODE_PROTOCOL_ERROR);            }            // CTS 6.3.6.5            if((GET_MHL_CBUS_STATE() == CBUS_STATE_SENT) && (preq.cmd == MSC_ABORT))            {                SET_MHL_RECEIVE_ABORT();            }            // CTS 6.3.6.4 & 6.3.6.5            if((preq.rcState != CBUS_RECEIVE_TIMEOUT) && (preq.cmd != MSC_ABORT))#endif            {                if(preq.cmd == MSC_ACK)                {                    SET_MHL_RECEIVE_ACK();                    if(preq.len > 0)                    {                        _mapi_mhl_InsertCbusAskData(preq.msgData[0]);                    }                }                SET_MHL_CBUS_STATE(CBUS_STATE_IDLE);            }        }    }#endif}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusQueueMscRxReply(BYTE subCmd, BYTE databuf)//  [Description]//                  MHL Cbus Reply MSC RCP or RAP into Queue//  [Arguments]://                  subCmd: MSC subcommands//                  databuf: command code//  [Return]://                  TRUE: success//                  FALSE: fail//**************************************************************************MS_BOOL _mapi_mhl_CbusQueueMscRxReply(MS_U8 subCmd, MS_U8 databuf){    CbusReq_S req;    req.cmd = MSC_MSC_MSG;    req.msgData[0] = subCmd;    req.msgData[1] = databuf;    req.len = 2;    req.rcState = FALSE;    req.reqStatus = CBUS_REQ_RECEIVED;    memcpy(&(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX)), &req, sizeof(CbusReq_S));    return TRUE;}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusRcpReply//  [Description]//                  MHL Cbus RCP response//  [Arguments]://                  statusCode: RCP status code//                  keyCode: RCP key code//  [Return]://                  TRUE: success//                  FALSE: fail//**************************************************************************MS_BOOL _mapi_mhl_CbusRcpReply(MS_U8 statusCode, MS_U8 keyCode){    MS_U8 ucSubCmd = MSC_MSG_RCPK;    MS_U8 ucKeyCode = keyCode;    if(statusCode != MHL_RCP_NO_ERROR)    {        ucSubCmd = MSC_MSG_RCPE;        ucKeyCode = statusCode;    }    SET_MHL_RX_MSG_COMMAND(ucSubCmd);    SET_MHL_RX_MSG_DATA(ucKeyCode);    return _mapi_mhl_CbusQueueMscRxReply(ucSubCmd, ucKeyCode);}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusRapReply//  [Description]//                  MHL Cbus RAP response//  [Arguments]://                  statusCode: RAP status code////  [Return]://                  TRUE: success//                  FALSE: fail//**************************************************************************MS_BOOL _mapi_mhl_CbusRapReply(MS_U8 statusCode){    MS_U8 ucSubCmd = MSC_MSG_RAPK;    MS_U8 ucKeyCode = statusCode;    SET_MHL_RX_MSG_COMMAND(ucSubCmd);    SET_MHL_RX_MSG_DATA(ucKeyCode);    return _mapi_mhl_CbusQueueMscRxReply(ucSubCmd, ucKeyCode);}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusUcpReply//  [Description]//                  MHL Cbus UCP response//  [Arguments]://                  statusCode: UCP status code//                  keyCode: UCP key code//  [Return]://                  TRUE: success//                  FALSE: fail//**************************************************************************MS_BOOL _mapi_mhl_CbusUcpReply(MS_U8 statusCode, MS_U8 keyCode){    MS_U8 ucSubCmd = MSC_MSG_UCPK;    MS_U8 ucKeyCode = keyCode;    if(statusCode != MHL_UCP_NO_ERROR)    {        ucSubCmd = MSC_MSG_UCPE;        ucKeyCode = statusCode;    }    SET_MHL_RX_MSG_COMMAND(ucSubCmd);    SET_MHL_RX_MSG_DATA(ucKeyCode);    return _mapi_mhl_CbusQueueMscRxReply(ucSubCmd, ucKeyCode);}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusAttReply//  [Description]//                  MHL Cbus ATT response//  [Arguments]://                  statusCode: ATT status code//                  keyCode: ATT key code//  [Return]://                  TRUE: success//                  FALSE: fail//**************************************************************************MS_BOOL _mapi_mhl_CbusAttReply(MS_U8 statusCode, MS_U8 keyCode){    MS_U8 ucSubCmd = MSC_MSG_ATTK;    MS_U8 ucKeyCode = statusCode;    SET_MHL_RX_MSG_COMMAND(ucSubCmd);    SET_MHL_RX_MSG_DATA(ucKeyCode);    return _mapi_mhl_CbusQueueMscRxReply(ucSubCmd, ucKeyCode);}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusRbpReply//  [Description]//                  MHL Cbus RBP response//  [Arguments]://                  statusCode: RBP status code//                  keyCode: RBP key code//  [Return]://                  TRUE: success//                  FALSE: fail//**************************************************************************MS_BOOL _mapi_mhl_CbusRbpReply(MS_U8 statusCode, MS_U8 keyCode){    MS_U8 ucSubCmd = MSC_MSG_RBPK;    MS_U8 ucKeyCode = keyCode;    if(statusCode != MHL_RBP_NO_ERROR)    {        ucSubCmd = MSC_MSG_RBPE;        ucKeyCode = statusCode;    }    SET_MHL_RX_MSG_COMMAND(ucSubCmd);    SET_MHL_RX_MSG_DATA(ucKeyCode);    return _mapi_mhl_CbusQueueMscRxReply(ucSubCmd, ucKeyCode);}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusMSGCommandProc()//  [Description]//                  MHL Cbus process MSC sub-command//  [Arguments]://                  subcmd: MSC sub-command//                  subdata: MSC sub-data//  [Return]:////**************************************************************************void _mapi_mhl_CbusMSGCommandProc(MS_U8 ucSubCmd, MS_U8 ucSubData){    MS_BOOL bReceiveResponse = FALSE;    MS_U8 ucStatus = MHL_RCP_NO_ERROR;    switch(ucSubCmd)    {        case MSC_MSG_RCP:            if(pfnMapi_mhl_CbusRcpProcess == NULL)            {                ucStatus = MHL_RCP_NO_ERROR;            }            else            {                ucStatus = pfnMapi_mhl_CbusRcpProcess(ucSubData);            }            _mapi_mhl_CbusRcpReply(ucStatus, ucSubData);            break;        case MSC_MSG_RCPK:        case MSC_MSG_RCPE:            bReceiveResponse = TRUE;            break;        case MSC_MSG_RAP:            if(pfnMapi_mhl_CbusRapProcess == NULL)            {                ucStatus = MHL_RAP_NO_ERROR;            }            else if(mdrv_mhl_CheckCbusModeChange(ucSubData))            {                if(mdrv_mhl_GetRAPEnableFlag())                {                    ucStatus = pfnMapi_mhl_CbusRapProcess(ucSubData);                }            }            _mapi_mhl_CbusRapReply(ucStatus);            break;        case MSC_MSG_RAPK:            bReceiveResponse = TRUE;            break;        case MSC_MSG_UCP:            if(pfnMapi_mhl_CbusUcpProcess == NULL)            {                ucStatus = MHL_UCP_NO_ERROR;            }            else            {                ucStatus = pfnMapi_mhl_CbusUcpProcess(ucSubData);            }            _mapi_mhl_CbusUcpReply(ucStatus, ucSubData);            break;        case MSC_MSG_UCPK:        case MSC_MSG_UCPE:            bReceiveResponse = TRUE;            break;        case MSC_MSG_ATT:            if(pfnMapi_mhl_CbusAttProcess == NULL)            {                ucStatus = MHL_ATT_NO_ERROR;            }            else            {                ucStatus = pfnMapi_mhl_CbusAttProcess(ucSubData);            }            _mapi_mhl_CbusAttReply(ucStatus, ucSubData);            break;        case MSC_MSG_ATTK:            bReceiveResponse = TRUE;            break;        case MSC_MSG_RBP:            if(pfnMapi_mhl_CbusRbpProcess == NULL)            {                ucStatus = MHL_RBP_NO_ERROR;            }            else            {                ucStatus = pfnMapi_mhl_CbusRbpProcess(ucSubData);            }            _mapi_mhl_CbusRbpReply(ucStatus, ucSubData);            break;        case MSC_MSG_RBPK:        case MSC_MSG_RBPE:            bReceiveResponse = TRUE;            break;        case MSC_MSG_RUSB:            break;        case MSC_MSG_RUSBK:            bReceiveResponse = TRUE;            break;        case MSC_MSG_RHID:            break;        case MSC_MSG_RHIDK:            bReceiveResponse = TRUE;            break;        case MSC_MSG_BIST_TRIGGRT:            mdrv_mhl_CbusBISTTriggerProc(ucSubData);            break;        case MSC_MSG_BIST_REQUEST_STAT:            mdrv_mhl_CbusBISTRequestStatusProc(ucSubData);            break;        case MSC_MSG_BIST_STOP:            mdrv_mhl_CbusBISTStopProc(ucSubData);            break;        default: // MSGE            break;    }    if(bReceiveResponse)    {        SET_MHL_SEND_MSG_FINISH();        CLR_MHL_SEND_MSG_COMMAND();    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusStatus()//  [Description]://                  MHL Cbus status//  [Arguments]:////  [Return]://                  TRUE: MHL Cbus connected//                  FALSE: MHL Cbus disconnected//**************************************************************************MS_BOOL _mapi_mhl_CbusStatus(void){    MS_U16 status;    status = mdrv_mhl_CbusStatus();    if(GET_MHL_CBUS_CONNECT() && ((status & 0x03) != 0x03))    {        SET_MHL_CBUS_STATE(CBUS_STATE_IDLE); // returm to idle state    }    if((status & 0x03) == 0x03)    {        SET_MHL_CBUS_CONNECT();    }    else    {        CLR_MHL_CBUS_CONNECT();    }    return GET_MHL_CBUS_CONNECT();}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CBusGetQueueIndex()//  [Description]://                  MHL Cbus get transmitting queue index//  [Arguments]:////  [Return]:////**************************************************************************MS_U8 _mapi_mhl_CBusGetQueueIndex(MS_U8 ucIndex){    MS_U8 uctemp = 0;    // Check Rx queue have packet transmit success or not    if(GET_MHL_QUEUE_STATE(MHL_CBUS_RX_QUEUE_INDEX) != CBUS_REQ_IDLE)    {#if(MHL_CBUS_OPERATION_MODE == MHL_CBUS_SW_ISR_MODE || MHL_CBUS_OPERATION_MODE == MHL_CBUS_HW_ISR_MODE)        if(GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).cmd != MSC_MSC_MSG)        {            GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).cmd = MSC_MSC_MSG;            GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[0] = GET_MHL_RX_MSG_COMMAND();            GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).msgData[1] = GET_MHL_RX_MSG_DATA();        }#endif        return MHL_CBUS_RX_QUEUE_INDEX;    }    // Check Tx queue have packet transmit success or not, search start  from current index    for(uctemp =0; uctemp <(MHL_CBUS_TOTAL_QUEUE_NUM -1); uctemp++)    {        if(GET_MHL_QUEUE_STATE((ucIndex +uctemp) %(MHL_CBUS_TOTAL_QUEUE_NUM -1)) != CBUS_REQ_IDLE)        {            return ((ucIndex +uctemp) %(MHL_CBUS_TOTAL_QUEUE_NUM -1));        }    }    return MHL_CBUS_TOTAL_QUEUE_NUM;}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusTxHandler()//  [Description]//                  MHL Cbus handle send MSC message//  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_CbusTimerHandler(MS_U32 ulTimer){#if(DMHL_TIMER_POLLING_INTERVAL)    static MS_U8 uc10msTick = CBUS_POLLING_TIMER_INTERVAL; // 10ms    MS_U32 ultemp = (GET_MHL_TIMEOUT_TIMER() +GET_MHL_DEBOUNCE_TIMER()) %CBUS_TIMER_CONTROL_MASK;   // Departure time    MS_U32 ul10msTimer = (GET_MHL_TIMEOUT_TIMER() +uc10msTick) %CBUS_TIMER_CONTROL_MASK;   // Departure time    // Current time    ulTimer = ulTimer %CBUS_TIMER_CONTROL_MASK;    // Compare current time and previous time, reset if too different    // In normal case, current time larger than previous time    if((ulTimer +CBUS_TIMER_CONTROL_MASK -GET_MHL_TIMEOUT_TIMER()) %CBUS_TIMER_CONTROL_MASK > (CBUS_TIMER_CONTROL_MASK /2))    {        // Reset Timer        CLR_MHL_TIME_OUT_FLAG();    }    if(ulTimer != GET_MHL_TIMEOUT_TIMER())    {        // Departure time minus current time        ultemp = (ultemp +CBUS_TIMER_CONTROL_MASK -ulTimer) %CBUS_TIMER_CONTROL_MASK;        if((ultemp == 0) || (ultemp > (CBUS_TIMER_CONTROL_MASK /2)))   // Current time larger than departure time        {            // CTS 6.3.6.4 verify DUT receives result timeout => couldn's send any MSC packet within 2sec            // CTS 6.3.6.5 verify no next command until hold-off after Abort seen => couldn's send any MSC packet within 2sec            if(GET_MHL_TIME_OUT_FLAG())            {                msg_mhl(printf("**MHL TOUT"));                SET_MHL_CBUS_STATE(CBUS_STATE_IDLE);                SET_MHL_QUEUE_STATE(gMHLInfo.MhlCbusInfo.curIdx, CBUS_REQ_IDLE);            }            _mapi_mhl_SetControlTimer(0);        }        else        {            SET_MHL_DEBOUNCE_TIMER(ultemp);        }        SET_MHL_TIMEOUT_TIMER(ulTimer);        // Departure time minus current time        ul10msTimer = (ul10msTimer +CBUS_TIMER_CONTROL_MASK -ulTimer) %CBUS_TIMER_CONTROL_MASK;        if((ul10msTimer == 0) || (ul10msTimer > (CBUS_TIMER_CONTROL_MASK /2)))   // Current time larger than departure time        {            uc10msTick = CBUS_POLLING_TIMER_INTERVAL;            _mapi_mhl_SetPowerOnTimer(0);            _mapi_mhl_SetReceiveLoseTime(0);            _mapi_mhl_SetMSGWaitReplyTime(0);            _mapi_mhl_SetRCPReleaseSendTime(0, RCP_KEYID_SELECT_RELEASE);            _mapi_mhl_SetCheckContentOnTime(0);            mdrv_mhl_SetBISTProcTimer(0);        }        else        {            uc10msTick = ul10msTimer;        }    }#else    ulTimer = ulTimer;    if(GET_MHL_DEBOUNCE_TIMER() > 0)    {        DEC_MHL_DEBOUNCE_TIMER();    }    // CTS 6.3.6.4 verify DUT receives result timeout => couldn's send any MSC packet within 2sec    // CTS 6.3.6.5 verify no next command until hold-off after Abort seen => couldn's send any MSC packet within 2sec    if(GET_MHL_TIME_OUT_FLAG() &&(!GET_MHL_TIMEOUT_TIMER()))    {        msg_mhl(printf("**MHL TOUT"));        SET_MHL_CBUS_STATE(CBUS_STATE_IDLE);        SET_MHL_QUEUE_STATE(gMHLInfo.MhlCbusInfo.curIdx, CBUS_REQ_IDLE);        _mapi_mhl_SetControlTimer(0);    }#endif}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusGetLeastFlag()//  [Description]://                  MHL Cbus get the least True flag in index//  [Arguments]:////  [Return]:////**************************************************************************MS_U8 _mapi_mhl_CbusGetLeastFlag(MS_U8 unindex){    MS_U8 uctemp = BIT(0);    if(unindex == 0)    {        return unindex;    }    while(!(unindex &uctemp))    {        uctemp = uctemp <<1;    }    return uctemp;}//**************************************************************************//  [Function Name]://                  _mapi_mhl_GetLeastBitNum()//  [Description]:////  [Arguments]:////  [Return]:////**************************************************************************MS_U8 _mapi_mhl_GetLeastBitNum(MS_U16 usData){    MS_U8 uctemp = 0;    while(!(usData &BIT(0)))    {        usData = usData >>1;        uctemp++;    }    return uctemp;}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusLinkCheck()//  [Description]//                  MHL Cbus handle send MSC message//  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_CbusLinkCheck(void){    MS_U8 ucDisplayIndex = GET_CBUS_DISPLAY_FLAG();    MS_U16 usDisplayCheck = GET_CBUS_DISPLAY_CHECK();    if((ucDisplayIndex ^ usDisplayCheck) > 0)    {        usDisplayCheck = usDisplayCheck ^ mdrv_mhl_GetCbusDisplayMask();        if(usDisplayCheck > 0)        {            usDisplayCheck = GET_CBUS_DISPLAY_CHECK() |_mapi_mhl_CbusGetLeastFlag(usDisplayCheck);            SET_CBUS_DISPLAY_FLAG(ucDisplayIndex |(usDisplayCheck << MHL_CBUS_DISPLAY_MASK_SHIFT));            msg_mhl(printf("**MHL Cbus Receive ACK for Link\r\n"));        }    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_TxQueueHandler()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_TxQueueHandler(void){    MS_U8 ucindex = 0;    switch(GET_MHL_CBUS_STATE())    {        case CBUS_STATE_IDLE:            ucindex = _mapi_mhl_CBusGetQueueIndex(gMHLInfo.MhlCbusInfo.curIdx);            if(!GET_MHL_RECEIVE_MSC() && (ucindex < MHL_CBUS_TOTAL_QUEUE_NUM) && !GET_MHL_DEBOUNCE_TIMER())            {                if(mdrv_mhl_CBusWriteCmd(&(GET_MHL_CBUS_QUEUE(ucindex))))                {                    // Retry send packet twice                    if(GET_MHL_QUEUE_STATE(ucindex) == CBUS_REQ_SENT)                    {                        SET_MHL_QUEUE_STATE(ucindex, CBUS_REQ_IDLE);                        msg_mhl(printf("MHL Tx retry"));                    }                    else if(GET_MHL_QUEUE_STATE(ucindex) > CBUS_REQ_SENT)                    {                        SET_MHL_QUEUE_STATE(ucindex, CBUS_REQ_SENT);                    }                    // Update current index to search index, but not Rx queue index                    if(ucindex < MHL_CBUS_RX_QUEUE_INDEX)                    {                        gMHLInfo.MhlCbusInfo.curIdx = ucindex;                    }                    if(GET_MHL_RX_MSG_COMMAND() > 0)                    {                        SET_MHL_RX_MSG_COMMAND(0xFF);                    }                    SET_MHL_CBUS_STATE(CBUS_STATE_SENT);                    _mapi_mhl_SetControlTimer(CBUS_COMMAND_TIMEOUT_SECS);                }            }            break;        case CBUS_STATE_SENT:        case CBUS_STATE_WAITING_ACK:        case CBUS_STATE_RECEIVED:            break;        case CBUS_STATE_ACK:            break;        default:            SET_MHL_CBUS_STATE(CBUS_STATE_IDLE);            break;    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusQueueMscTxRequest(BYTE ucIndex, CbusReq_S *pReq)//  [Description]//                  MHL Cbus Request a MSC Cmd into Queue//  [Arguments]://                  ucIndex: Current queue index//                  pReq: Command buffer//  [Return]://                  TRUE: success//                  FALSE: fail//**************************************************************************MS_BOOL _mapi_mhl_CbusQueueMscTxRequest(MS_U8 ucIndex, CbusReq_S *pReq){    MS_U8 uctemp = ucIndex;    if(!mdrv_mhl_GetCbusTxQueueFreeze())    {        // Search free queue        for(uctemp = 0; uctemp <(MHL_CBUS_TOTAL_QUEUE_NUM -1); uctemp++)        {            if(GET_MHL_QUEUE_STATE((ucIndex +uctemp +1) %(MHL_CBUS_TOTAL_QUEUE_NUM -1)) == CBUS_REQ_IDLE)            {                uctemp = (ucIndex +uctemp +1) %(MHL_CBUS_TOTAL_QUEUE_NUM -1);                break;            }        }        if(uctemp == (MHL_CBUS_TOTAL_QUEUE_NUM -1)) // No free queue        {            return FALSE;        }        if(GET_MHL_QUEUE_STATE((uctemp +MHL_CBUS_TOTAL_QUEUE_NUM -2) %(MHL_CBUS_TOTAL_QUEUE_NUM -1)) == CBUS_REQ_IDLE)        {            uctemp = (uctemp +MHL_CBUS_TOTAL_QUEUE_NUM -2) %(MHL_CBUS_TOTAL_QUEUE_NUM -1);        }        memcpy(&(GET_MHL_CBUS_QUEUE(uctemp)), pReq, sizeof(CbusReq_S));    }    return TRUE;}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusSendSetHPD()//  [Description]://                  MHL Cbus set HPD state//  [Arguments]://                  TRUE: SET_HPD//                  FALSE: CLR_HPD//  [Return]:////**************************************************************************MS_BOOL _mapi_mhl_CbusSendSetHPD(MS_BOOL bflag){    MS_BOOL bIndex;    CbusReq_S req;    if(GET_MHL_HPD_SET_FLAG() == bflag)    {        return TRUE;    }    req.cmd = (bflag == TRUE ? MSC_SET_HPD : MSC_CLR_HPD);    req.len = 0;    req.reqStatus = CBUS_REQ_PENDING;    bIndex = _mapi_mhl_CbusQueueMscTxRequest(gMHLInfo.MhlCbusInfo.curIdx, &req);    if(bIndex)    {        if(bflag)        {            SET_MHL_HPD_SET_FLAG();        }        else        {            CLR_MHL_HPD_SET_FLAG();        }    }    return bIndex;}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusWriteStatusOrSetInt(BYTE addr, BYTE val)//  [Description]://                  MHL Cbus write status or set interrupt//  [Arguments]:////  [Return]://                  TRUE: Cbus message send successfully//                  FALSE: Cbus message send fail//**************************************************************************MS_BOOL _mapi_mhl_CbusWriteStatusOrSetInt(MS_U8 ucAddr, MS_U8 ucValue, MS_BOOL bExtended){    CbusReq_S req;    if(bExtended)    {        req.cmd = MSC_WRITE_XSTAT;    }    else    {        req.cmd = MSC_WRITE_STAT_OR_SET_INT;    }        req.msgData[0] = ucAddr;    req.msgData[1] = ucValue;    req.len = 2;    req.reqStatus = CBUS_REQ_PENDING;    if(!_mapi_mhl_CbusQueueMscTxRequest(gMHLInfo.MhlCbusInfo.curIdx, &req))    {        return FALSE;    }    return TRUE;}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusSendDevcapReady()//  [Description]://                  MHL Cbus set capbility ready//  [Arguments]://                  TRUE: Enable//                  FALSE: Disable//  [Return]:////**************************************************************************void _mapi_mhl_CbusSendDevcapReady(MS_BOOL bflag){    MS_BOOL bIndex = FALSE;    if(bflag)    {        //set DCAP_RDY bit        bIndex = _mapi_mhl_CbusWriteStatusOrSetInt(0x30, mdrv_mhl_GetDevcapReadyValue(), FALSE);    }    if(bIndex || (!bflag))    {        if(bflag)        {            SET_MHL_DCAP_RDY_FLAG();        }        else        {            CLR_MHL_DCAP_RDY_FLAG();        }    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusSendPathEnable()//  [Description]://                  MHL Cbus set path enable//  [Arguments]://                  TRUE: Enable//                  FALSE: Disable//  [Return]:////**************************************************************************void _mapi_mhl_CbusSendPathEnable(MS_BOOL bflag){    MS_BOOL bIndex = FALSE;    bIndex = _mapi_mhl_CbusWriteStatusOrSetInt(0x31, bflag ? BIT(3) : 0, FALSE);    if(bIndex || (!bflag))    {        if(bflag)        {            SET_MHL_PATH_EN_FLAG();        }        else        {            CLR_MHL_PATH_EN_FLAG();        }        mdrv_mhl_Cbus_SetPathEn(bflag);    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusSendDevcapChange(Bool bflag)//  [Description]://                  MHL Cbus set path enable//  [Arguments]://                  TRUE: Enable//                  FALSE: Disable//  [Return]:////**************************************************************************void _mapi_mhl_CbusSendDevcapChange(MS_BOOL bflag){    MS_BOOL bIndex = FALSE;    if(bflag)    {        bIndex = _mapi_mhl_CbusWriteStatusOrSetInt(0x20, BIT(0), FALSE);    }    if (bIndex || (!bflag))    {        if(bflag)        {            SET_MHL_DCAP_CHG_FLAG();        }        else        {            CLR_MHL_DCAP_CHG_FLAG();        }    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusSendVersionCode(Bool bflag)//  [Description]:////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_CbusSendVersionCode(void){    MS_BOOL bFlag = FALSE;    bFlag = _mapi_mhl_CbusWriteStatusOrSetInt(0x32, mdrv_mhl_GetDevCap(MHL_CBUS_VERSION), FALSE);        if(bFlag)    {        SET_MHL_VERSION_CODE();    }    else    {        CLR_MHL_VERSION_CODE();    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusSendLinkStatusNormal(Bool bflag)//  [Description]://                  //  [Arguments]://                  //  [Return]:////**************************************************************************void _mapi_mhl_CbusSendLinkStatusNormal(void){    MS_BOOL bFlag = FALSE;    if(mdrv_mhl_CheckECbusStateNormal())    {        bFlag = _mapi_mhl_CbusWriteStatusOrSetInt(0x91, 0x02, TRUE);    }        if(bFlag)    {        SET_MHL_LINK_STATUS_NORMAL();    }    else    {        CLR_MHL_LINK_STATUS_NORMAL();    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusStatusConstruct()//  [Description]:////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL _mapi_mhl_CbusStatusConstruct(MS_BOOL bReset){    static MS_BOOL bInitial = FALSE;    static MS_U8 ucToggle = 0;    if((ucToggle == 0) && GET_MHL_POWER_ON_TIMER())    {        if(mdrv_mhl_CableDetect())        {            bReset = TRUE;        }    }    if(bInitial)    {        if(GET_MHL_CBUS_CONNECT())        {            bInitial = FALSE;        }        else        {            if(!GET_MHL_DEBOUNCE_TIMER())            {                if(ucToggle %2)                {                    SET_MHL_DEBOUNCE_TIMER(50);                    mdrv_mhl_CbusPadConfigSwitch(TRUE);                }                else                {                    SET_MHL_DEBOUNCE_TIMER(50);                    mdrv_mhl_CbusPadConfigSwitch(FALSE);                    msg_mhl(printf("** MHL toggle Cbus floating @@!!@@\r\n"));                }                ucToggle++;                if(ucToggle == 4)                {                    bInitial = FALSE;                    mapi_mhl_AutoSwitchHandler(TRUE, &ucToggle);                }            }        }    }    if(bReset)    {        bInitial = TRUE;        ucToggle = 1;    }    return bInitial;}//**************************************************************************//  [Function Name]://                  _mapi_mhl_SendDisplayCommand()//  [Description]:////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_SendDisplayCommand(void){    MS_U8 ucindex = 0;    if(mdrv_mhl_CheckSendCommand(GET_MHL_FORCE_SEND_COMMAND()))    {        ucindex = GET_CBUS_DISPLAY_FLAG() ^ mdrv_mhl_GetCbusDisplayMask();        if(ucindex > 0)        {            switch(_mapi_mhl_CbusGetLeastFlag(ucindex))            {                case MHL_CBUS_HPD_SET_FLAG:                    _mapi_mhl_CbusSendSetHPD(TRUE);                    break;                case MHL_CBUS_DEVCAP_READY_FLAG:                    _mapi_mhl_CbusSendDevcapReady(TRUE);                    break;                case MHL_CBUS_PATH_EN_FLAG:                    _mapi_mhl_CbusSendPathEnable(TRUE);                    break;                case MHL_CBUS_DEVCAP_CHANGE_FLAG:                    _mapi_mhl_CbusSendDevcapChange(TRUE);                    break;                case MHL_CBUS_VERSION_CODE_FLAG:                    _mapi_mhl_CbusSendVersionCode();                    break;                case MHL_CBUS_LINK_STATUS_NORMAL_FLAG:                    _mapi_mhl_CbusSendLinkStatusNormal();                    break;                default:                    break;            };        }    }    else // Not MHL port    {        if(GET_MHL_SEND_CHECK_CONTENT_ON())        {            if(!GET_MHL_HPD_SET_FLAG())            {                _mapi_mhl_CbusSendSetHPD(TRUE);            }            if(GET_MHL_PATH_EN_FLAG())            {                _mapi_mhl_CbusSendPathEnable(FALSE);            }            if(!GET_MHL_DCAP_RDY_FLAG())            {                _mapi_mhl_CbusSendDevcapReady(TRUE);            }        }        else        {            if(GET_MHL_HPD_SET_FLAG())            {                _mapi_mhl_CbusSendSetHPD(FALSE);                if(GET_MHL_LINK_STATUS_NORMAL())                {                    CLR_MHL_LINK_STATUS_NORMAL();                }            }            if(GET_MHL_ROKU_DEVICE_FLAG())            {                if(!GET_MHL_DCAP_RDY_FLAG())                {                    _mapi_mhl_CbusSendDevcapReady(TRUE);                }                if(!GET_MHL_PATH_EN_FLAG())                {                    _mapi_mhl_CbusSendPathEnable(TRUE);                }            }            if(GET_MHL_HTC_PHONE_FLAG())            {                if(!GET_MHL_DCAP_RDY_FLAG())                {                    _mapi_mhl_CbusSendDevcapReady(TRUE);                }            }        }    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_WriteBurstEventProc()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_WriteBurstEventProc(void){    switch(GET_MHL_WRITE_BURST_STATE())    {        case MHL_CBUS_WRITE_BURST_START:            if(_mapi_mhl_CbusWriteStatusOrSetInt(0x20, BIT(2), FALSE))            {                SET_MHL_WRITE_BURST_STATE(MHL_CBUS_WRITE_BURST_SEND_REQUEST);            }            break;        case MHL_CBUS_WRITE_BURST_SEND_DATA:            if(_mapi_mhl_CbusWriteStatusOrSetInt(0x20, BIT(1), FALSE))            {                SET_MHL_WRITE_BURST_STATE(MHL_CBUS_WRITE_BURST_END);            }            break;                    case MHL_CBUS_WRITE_BURST_END:            SET_MHL_WRITE_BURST_STATE(MHL_CBUS_WRITE_BURST_NONE);            break;        default:            break;    };}//**************************************************************************//  [Function Name]://                  _mapi_mhl_Send3DTimingInformation()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_Send3DTimingInformation(void){    MS_BOOL bFinish = FALSE;    MS_U8 uc3DSequence = 0;    MS_U8 ucData[MHL_MSC_SCRATCHPAD_SIZE] = {0};    if(GET_MHL_SEND_3D_DTD())    {        if(mdrv_mhl_GetDTDBurstfor3D(ucData, &uc3DSequence))        {            bFinish = TRUE;        }        if(mapi_mhl_SendWriteBurst(0x40, MHL_MSC_SCRATCHPAD_SIZE, ucData))        {            if(bFinish)            {                CLR_MHL_SEND_3D_DTD();            }            SET_MHL_WRITE_BURST_SEQUENCE(uc3DSequence);            SET_MHL_WRITE_BURST_STATE(MHL_CBUS_WRITE_BURST_SEND_DATA);            msg_mhl(printf("** MHL sent 3D DTD port %c in %d\r\n", MHL_INPUT_PORT(mdrv_mhl_GetCbusPath()), ucData[4]));        }    }    else if(GET_MHL_SEND_3D_VIC())    {        if(mdrv_mhl_GetVICBurstfor3D(ucData, &uc3DSequence))        {            bFinish= TRUE;        }        if(mapi_mhl_SendWriteBurst(0x40, MHL_MSC_SCRATCHPAD_SIZE, ucData))        {            if(bFinish)            {                CLR_MHL_SEND_3D_VIC();                CLR_MHL_SEND_3D_INFORMATION();            }            SET_MHL_WRITE_BURST_SEQUENCE(uc3DSequence);            SET_MHL_WRITE_BURST_STATE(MHL_CBUS_WRITE_BURST_SEND_DATA);            msg_mhl(printf("** MHL sent 3D VIC port %c in %d\r\n", MHL_INPUT_PORT(mdrv_mhl_GetCbusPath()), ucData[4]));        }    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_SendVirtualChannelInformation()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_SendVirtualChannelInformation(void){    MS_BOOL bFinish = FALSE;    MS_BOOL bSendVCConfirm = FALSE;    MS_U8 ucVCSequence = 0;    MS_U8 ucData[MHL_MSC_SCRATCHPAD_SIZE] = {0};    if(mdrv_mhl_GetBurstforVirtualChannel(GET_MHL_SEND_VC_CONFIRM(), &ucVCSequence, ucData))    {        bFinish = TRUE;    }    if(mapi_mhl_SendWriteBurst(0x40, MHL_MSC_SCRATCHPAD_SIZE, ucData))    {        if(bFinish)        {            if(GET_MHL_SEND_VC_CONFIRM())            {                CLR_MHL_SEND_VC_CONFIRM();                bSendVCConfirm = TRUE;            }            CLR_MHL_SEND_VC_INFORMATION();        }        SET_MHL_WRITE_BURST_SEQUENCE(ucVCSequence);        SET_MHL_WRITE_BURST_STATE(MHL_CBUS_WRITE_BURST_SEND_DATA);        msg_mhl(printf("** MHL sent VC information port %c in %d\r\n", MHL_INPUT_PORT(mdrv_mhl_GetCbusPath()), ucData[4]));    }	bSendVCConfirm = bSendVCConfirm;}//**************************************************************************//  [Function Name]://                  _mapi_mhl_SendHighEndVideoSupport()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_SendHighEndVideoSupport(void){    MS_BOOL bFinish = FALSE;    MS_U8 ucHEVSequence = 0;    MS_U8 ucData[MHL_MSC_SCRATCHPAD_SIZE] = {0};    if(GET_MHL_SEND_HEV_VIC())    {        if(mdrv_mhl_GetHighEndVideoVIC(&ucHEVSequence, ucData))        {            bFinish = TRUE;        }        if(mapi_mhl_SendWriteBurst(0x40, MHL_MSC_SCRATCHPAD_SIZE, ucData))        {            if(bFinish)            {                CLR_MHL_SEND_HEV_VIC();            }            SET_MHL_WRITE_BURST_SEQUENCE(ucHEVSequence);            SET_MHL_WRITE_BURST_STATE(MHL_CBUS_WRITE_BURST_SEND_DATA);            msg_mhl(printf("** MHL sent HEV VIC port %c in %d\r\n", MHL_INPUT_PORT(mdrv_mhl_GetCbusPath()), ucData[4]));        }    }    else if(GET_MHL_SEND_HEV_DTDA())    {        if(mdrv_mhl_GetHighEndVideoDTDA(&ucHEVSequence, ucData))        {            bFinish = TRUE;        }        if(mapi_mhl_SendWriteBurst(0x40, MHL_MSC_SCRATCHPAD_SIZE, ucData))        {            if(bFinish)            {                CLR_MHL_SEND_HEV_DTDA();            }            SET_MHL_WRITE_BURST_SEQUENCE(ucHEVSequence);            SET_MHL_WRITE_BURST_STATE(MHL_CBUS_WRITE_BURST_SEND_DATA);            msg_mhl(printf("** MHL sent HEV DTDA port %c in %d\r\n", MHL_INPUT_PORT(mdrv_mhl_GetCbusPath()), ucData[4]));        }    }    else if(GET_MHL_SEND_HEV_DTDB())    {        if(mdrv_mhl_GetHighEndVideoDTDB(&ucHEVSequence, ucData))        {            bFinish = TRUE;        }        if(mapi_mhl_SendWriteBurst(0x40, MHL_MSC_SCRATCHPAD_SIZE, ucData))        {            if(bFinish)            {                CLR_MHL_SEND_HEV_DTDB();                CLR_MHL_SEND_HIGH_END_VIDEO();            }            SET_MHL_WRITE_BURST_SEQUENCE(ucHEVSequence);            SET_MHL_WRITE_BURST_STATE(MHL_CBUS_WRITE_BURST_SEND_DATA);            msg_mhl(printf("** MHL sent HEV DTDB port %c in %d\r\n", MHL_INPUT_PORT(mdrv_mhl_GetCbusPath()), ucData[4]));        }    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_SendAudioDataTunnelSupport()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_SendAudioDataTunnelSupport(void){    MS_BOOL bFinish = FALSE;    MS_U8 ucADTSequence = 0;    MS_U8 ucData[MHL_MSC_SCRATCHPAD_SIZE] = {0};    if(mdrv_mhl_GetAudioDataTunnel(&ucADTSequence, ucData))    {        bFinish = TRUE;    }    if(mapi_mhl_SendWriteBurst(0x40, MHL_MSC_SCRATCHPAD_SIZE, ucData))    {        if(bFinish)        {            CLR_MHL_SEND_AUDIO_DATA_TUNNEL();        }        SET_MHL_WRITE_BURST_SEQUENCE(ucADTSequence);        SET_MHL_WRITE_BURST_STATE(MHL_CBUS_WRITE_BURST_SEND_DATA);        msg_mhl(printf("** MHL sent audio tunnel port %c in %d\r\n", MHL_INPUT_PORT(mdrv_mhl_GetCbusPath()), ucData[4]));    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_SendeMSCSupportInformation()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_SendeMSCSupportInformation(void){    MS_BOOL bFinish = FALSE;    MS_U8 ucMSCSequence = 0;    MS_U8 ucData[MHL_MSC_SCRATCHPAD_SIZE] = {0};    if(mdrv_mhl_GeteMSCSupportInformation(&ucMSCSequence, ucData))    {        bFinish = TRUE;    }    if(mapi_mhl_SendWriteBurst(0x40, MHL_MSC_SCRATCHPAD_SIZE, ucData))    {        if(bFinish)        {            CLR_MHL_SEND_EMSC_DATA_TUNNEL();        }        SET_MHL_WRITE_BURST_SEQUENCE(ucMSCSequence);        SET_MHL_WRITE_BURST_STATE(MHL_CBUS_WRITE_BURST_SEND_DATA);        msg_mhl(printf("** MHL sent eMSC support port %c in %d\r\n", MHL_INPUT_PORT(mdrv_mhl_GetCbusPath()), ucData[4]));    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_SendBISTReturnStatus()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_SendBISTReturnStatus(void){    MS_U8 ucData[MHL_MSC_SCRATCHPAD_SIZE] = {0};    mdrv_mhl_GetBISTReturnStatus(ucData);    if(mapi_mhl_SendWriteBurst(0x40, MHL_MSC_SCRATCHPAD_SIZE, ucData))    {        CLR_MHL_SEND_BIST_RETURN_STATUS();        SET_MHL_WRITE_BURST_STATE(MHL_CBUS_WRITE_BURST_SEND_DATA);    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_SendWriteBurstInformation()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_SendWriteBurstInformation(void){    MS_BOOL bSendWriteBurst = FALSE;    MS_U8 ucWriteBurstType = MHL_CBUS_SEND_WRITE_BURST_NONE;    if(GET_MHL_SEND_USER_WRITE_BURST())    {        ucWriteBurstType = MHL_CBUS_SEND_WRITE_BURST_USER_DATA;    }    else if(GET_MHL_SEND_3D_INFORMATION())    {        ucWriteBurstType = MHL_CBUS_SEND_WRITE_BURST_3D_INFORMATION;    }    else if(GET_MHL_SEND_VC_INFORMATION())    {        ucWriteBurstType = MHL_CBUS_SEND_WRITE_BURST_VIRTUAL_CHANNEL;    }    else if(GET_MHL_SEND_HIGH_END_VIDEO())    {        ucWriteBurstType = MHL_CBUS_SEND_WRITE_BURST_HIGH_END_VIDEO;    }    else if(GET_MHL_SEND_AUDIO_DATA_TUNNEL())    {        ucWriteBurstType = MHL_CBUS_SEND_WRITE_BURST_AUDIO_DATA_TUNNEL;    }    else if(GET_MHL_SEND_EMSC_DATA_TUNNEL())    {        ucWriteBurstType = MHL_CBUS_SEND_WRITE_BURST_EMSC_DATA_TUNNEL;    }    else if(GET_MHL_SEND_BIST_RETURN_STATUS())    {        ucWriteBurstType = MHL_CBUS_SEND_WRITE_BURST_BIST_RETURN_STATUS;    }    if(ucWriteBurstType != MHL_CBUS_SEND_WRITE_BURST_NONE)    {        if(GET_MHL_WRITE_BURST_STATE() == MHL_CBUS_WRITE_BURST_NONE)        {            SET_MHL_WRITE_BURST_STATE(MHL_CBUS_WRITE_BURST_START);        }        else if(GET_MHL_WRITE_BURST_STATE() == MHL_CBUS_WRITE_BURST_REVEIVE_GRANT)        {            bSendWriteBurst = TRUE;        }    }    if(bSendWriteBurst)    {        switch(ucWriteBurstType)        {            case MHL_CBUS_SEND_WRITE_BURST_3D_INFORMATION:                _mapi_mhl_Send3DTimingInformation();                break;            case MHL_CBUS_SEND_WRITE_BURST_VIRTUAL_CHANNEL:                _mapi_mhl_SendVirtualChannelInformation();                break;            case MHL_CBUS_SEND_WRITE_BURST_HIGH_END_VIDEO:                _mapi_mhl_SendHighEndVideoSupport();                break;            case MHL_CBUS_SEND_WRITE_BURST_AUDIO_DATA_TUNNEL:                _mapi_mhl_SendAudioDataTunnelSupport();                break;            case MHL_CBUS_SEND_WRITE_BURST_EMSC_DATA_TUNNEL:                _mapi_mhl_SendeMSCSupportInformation();                break;            case MHL_CBUS_SEND_WRITE_BURST_BIST_RETURN_STATUS:                _mapi_mhl_SendBISTReturnStatus();                break;            default:                break;        };    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusConnectionCheck()//  [Description]://                  MHL Cbus connection check//  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_CbusConnectionCheck(void){    MS_U8 ucCbusSelect = 0;    static MS_BOOL bCbusConnected = FALSE;    if(bCbusConnected != GET_MHL_CBUS_CONNECT())    {        bCbusConnected = GET_MHL_CBUS_CONNECT();        if(!bCbusConnected)        {            gMHLInfo.MhlCbusInfo.curIdx = 0;            SET_MHL_CBUS_STATE(CBUS_STATE_IDLE);            SET_MHL_CBUS_ERROE_CODE(MSC_ERRORCODE_NO_ERROR);            CLR_MHL_CONNECT_FLAG();            _mapi_mhl_SetControlTimer(0);            ucCbusSelect = mdrv_mhl_CbusStucktoLowProc();            msg_mhl(printf("** MHL Cbus stuck to low @@ port %c\r\n", MHL_INPUT_PORT(ucCbusSelect)));            memset(&gMHLInfo.MhlCbusInfo.request, 0, sizeof(gMHLInfo.MhlCbusInfo.request));            mdrv_mhl_CableDetect();        }        else        {            SET_MHL_DEBOUNCE_TIMER(CBUS_MSC_WAIT_TIME_MS); // reset 100msec            mdrv_mhl_CbusConnectProc();            CLR_MHL_CELL_PHONE_FLAG();            SET_MHL_WRITE_BURST_ADDRESS(0);            SET_MHL_GET_VENDER_ID_ENABLE();            SET_MHL_WRITE_BURST_STATE(MHL_CBUS_WRITE_BURST_NONE);            if(GET_MHL_CHECK_CONTENT_ENABLE())            {                if(!mdrv_mhl_CheckSendCommand(GET_MHL_FORCE_SEND_COMMAND())) // Check off line                {                    _mapi_mhl_SetCheckContentOnTime(CBUS_CHECK_CONTENT_ON_INTERVAL);                }            }        }    }    if(bCbusConnected)    {        if(mdrv_mhl_CBusStablePolling(GET_CBUS_DISPLAY_READY()))        {            mdrv_mhl_CbusIsolate(TRUE);            CLR_MHL_PORT_ON_FLAG();        }        if(GET_MHL_ENABLE_CBUS_ENHANCE()) // For MHL 3.0        {            mdrv_mhl_ECbusStateHandler();        }    }    else    {        if(!GET_MHL_DEBOUNCE_TIMER())        {            if(mdrv_mhl_AutoSwitchCbusSelect())            {                // Do nothing            }            SET_MHL_DEBOUNCE_TIMER(CBUS_SWITCH_MUX_TIME_MS);        }    }    //_mapi_mhl_CbusStatusConstruct(FALSE);}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusMscMsgSubCmdSend//  [Description]//                  MHL Cbus MSC Send RCP or RAP//  [Arguments]://                  subCmd: MSC subcommands//                  databuf: command code//  [Return]://                  TRUE: success//                  FALSE: fail//**************************************************************************MS_BOOL _mapi_mhl_CbusMscMsgSubCmdSend (MS_U8 ucSubCommand, MS_U8 ucKeyCode, MS_BOOL bWaitReply){    MS_BOOL bSendMSG = FALSE;    CbusReq_S stQueue;    if(!GET_MHL_SEND_MSG_COMMAND())    {        stQueue.cmd = MSC_MSC_MSG;        stQueue.msgData[0] = ucSubCommand;        stQueue.msgData[1] = ucKeyCode;        stQueue.len = 2;        stQueue.reqStatus = CBUS_REQ_PENDING;        bSendMSG = _mapi_mhl_CbusQueueMscTxRequest(gMHLInfo.MhlCbusInfo.curIdx, &stQueue);        if(bWaitReply && bSendMSG)        {            _mapi_mhl_SetMSGWaitReplyTime(CBUS_WAIT_MSC_RESPONSE_INTERVAL);        }    }    return bSendMSG;}//**************************************************************************//  [Function Name]://                  _mapi_mhl_GetCbusAskData//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL _mapi_mhl_GetCbusAskData(MS_U8 *ucData){    MS_BOOL bindex = FALSE;    if(GET_MHL_SEND_ASK_FINISH())    {        CLR_MHL_SEND_ASK_FINISH();        *ucData = GET_MHL_CBUS_ASK_DATA();        bindex = TRUE;    }    return bindex;}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusSendReadDevcap//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_CbusSendReadDevcap(MS_U8 ucBitNumber, MS_BOOL bExtended){    CbusReq_S stQueue;    if((!GET_MHL_SEND_ASK_DATA()) && (!GET_MHL_SEND_ASK_FINISH()))    {        if(bExtended)        {            stQueue.cmd = MSC_READ_XDEVCAP;            stQueue.msgData[0] = 0x80 +ucBitNumber;        }        else        {            stQueue.cmd = MSC_READ_DEVCAP;            stQueue.msgData[0] = ucBitNumber;        }        stQueue.len = 1;        stQueue.reqStatus = CBUS_REQ_PENDING;        if(_mapi_mhl_CbusQueueMscTxRequest(gMHLInfo.MhlCbusInfo.curIdx, &stQueue))        {            SET_MHL_SEND_ASK_DATA();            SET_MHL_SEND_READ_DEVCAP();        }    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusSendReadVenderID//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_CbusSendReadVenderID(void){    CbusReq_S stQueue;    if((!GET_MHL_SEND_ASK_DATA()) && (!GET_MHL_SEND_ASK_FINISH()))    {        stQueue.cmd = MSC_GET_VENDOR_ID;        stQueue.len = 0;        stQueue.reqStatus = CBUS_REQ_PENDING;        if(_mapi_mhl_CbusQueueMscTxRequest(gMHLInfo.MhlCbusInfo.curIdx, &stQueue))        {            SET_MHL_SEND_ASK_DATA();            SET_MHL_SEND_GET_VENDER_ID();        }    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusReadVenderID//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL _mapi_mhl_CbusReadVenderID(MS_U8 *ucData, MS_BOOL bCheckReceive){    MS_BOOL bGetData = FALSE;    if(bCheckReceive)    {        if(_mapi_mhl_GetCbusAskData(ucData))        {            bGetData = TRUE;        }    }    else    {        _mapi_mhl_CbusSendReadVenderID();    }    return bGetData;}//**************************************************************************//  [Function Name]://                  _mapi_mhl_ForceClearHPD()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_ForceClearHPD(void){    CbusReq_S stQueue;    if(!mdrv_mhl_CheckSendCommand(GET_MHL_FORCE_SEND_COMMAND()))    {        stQueue.cmd = MSC_CLR_HPD;        stQueue.len = 0;        if(mdrv_mhl_CBusWriteCmd(&stQueue))        {            CLR_MHL_HPD_SET_FLAG();            SET_MHL_CBUS_STATE(CBUS_STATE_SENT);            _mapi_mhl_SetControlTimer(CBUS_COMMAND_TIMEOUT_SECS);        }    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_IsrHandler()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************static void _mapi_mhl_IsrHandler(InterruptNum eIntNum){    UNUSED(eIntNum);    //MsOS_DisableInterrupt(E_INT_IRQ_MHL_CBUS_PM);    if(mdrv_mhl_CbusIsMscMsgReceived())    {        SET_MHL_RECEIVE_MSC();        INC_MHL_RX_RECEIVE_COUNTER();        CLR_MHL_RECEIVE_LOSE_FLAG();#if(MHL_CBUS_OPERATION_MODE == MHL_CBUS_SW_ISR_MODE ||MHL_CBUS_OPERATION_MODE == MHL_CBUS_HW_ISR_MODE)        _mapi_mhl_CbusIntCB();        _mapi_mhl_CbusIntHandler();#endif    }    if(mdrv_mhl_CbusStucktoLowFlag())    {        mdrv_mhl_CbusStucktoLowProc();    }    if(mdrv_mhl_CbusWakeupIntFlag())    {        SET_MHL_RECEIVE_WAKE();    }    //msg_mhl(printf("** MHL Cbus into ISR %x\r\n", GET_MHL_CBUS_QUEUE(MHL_CBUS_RX_QUEUE_INDEX).cmd));    if(mdrv_mhl_CheckIsrUsePMPath())    {        MsOS_EnableInterrupt(E_INT_IRQ_PM);    }    else    {        MsOS_EnableInterrupt(E_INT_IRQ_MHL_CBUS_PM);    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_ECbusIsrHandler()//  [Description]//                  //  [Arguments]://                  //  [Return]:////**************************************************************************static void _mapi_mhl_ECbusIsrHandler(InterruptNum eIntNum){    UNUSED(eIntNum);    if(mdrv_mhl_GetECbusStateChangeFlag())    {    }        MsOS_EnableInterrupt(E_INT_IRQ_MHL_ECBUS_INT);}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusReadDeviceCapacibility//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL _mapi_mhl_CbusReadDeviceCapacibility(MS_U8 ucBitNumber, MS_U8 *ucDevCapData, MS_BOOL bCheckReceive, MS_BOOL bExtended){    MS_BOOL bGetData = FALSE;    if(bCheckReceive)    {        if(_mapi_mhl_GetCbusAskData(ucDevCapData))        {            bGetData = TRUE;        }    }    else    {        _mapi_mhl_CbusSendReadDevcap(ucBitNumber, bExtended);    }    return bGetData;}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CheckDeviceCapacibility()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_CheckDeviceCapacibility(MS_U8 *ucDevcap){    MS_U16 usAdopterID = 0;    MS_U16 usDeviceID = 0;    usAdopterID = *(ucDevcap +4) |((*(ucDevcap +3)) << 8);    usDeviceID = *(ucDevcap +12) |((*(ucDevcap +11)) << 8);    CLR_MHL_CELL_PHONE_FLAG();    if(usAdopterID == MHL_ADOPTER_ID_ROKU)    {        SET_MHL_ROKU_DEVICE_FLAG();    }    if(usAdopterID == MHL_ADOPTER_ID_HTC)    {        SET_MHL_HTC_PHONE_FLAG();    }    if(usDeviceID == MHL_DEVICE_ID_HTC)    {        // Do nothing    }    if(ucDevcap[MHL_CBUS_VERSION] >= 0x30)    {        SET_MHL_RECEIVE_MHL3_VERSION();    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusBISTStateProc()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_CbusBISTStateProc(void){    MS_U8 ucBISTECbusMode = 0;        switch(GET_MHL_BIST_PROCESS_STATE())    {        case MHL_CBUS_BIST_RECEIVE_SETUP:            if(_mapi_mhl_CbusMscMsgSubCmdSend(MSC_MSG_BIST_READY, mdrv_mhl_GetBISTReadyIndex(), FALSE)) // Send BIST ready            {                SET_MHL_BIST_PROCESS_STATE(MHL_CBUS_BIST_WAIT_TRIGGER);            }            break;        case MHL_CBUS_BIST_RECEIVE_TRIGGER:            SET_MHL_BIST_PROCESS_STATE(MHL_CBUS_BIST_ECBUS_SWITCH);            ucBISTECbusMode = MHL_RAP_KEY_CBUS_MODE_UP;            break;        case MHL_CBUS_BIST_EVENT_FINISH:            SET_MHL_BIST_PROCESS_STATE(MHL_CBUS_BIST_WAIT_TRIGGER);            ucBISTECbusMode = MHL_RAP_KEY_CBUS_MODE_DOWN;            break;        case MHL_CBUS_BIST_REQUEST_STATUS:            SET_MHL_SEND_BIST_RETURN_STATUS();            SET_MHL_BIST_PROCESS_STATE(MHL_CBUS_BIST_RETURN_STATUS);            break;        case MHL_CBUS_BIST_RETURN_STATUS:            if(!GET_MHL_SEND_BIST_RETURN_STATUS())            {                SET_MHL_BIST_PROCESS_STATE(MHL_CBUS_BIST_WAIT_TRIGGER);            }            break;        case MHL_CBUS_BIST_END:            SET_MHL_BIST_PROCESS_STATE(MHL_CBUS_BIST_NONE);            break;        default:            break;    };    if(ucBISTECbusMode > 0)    {        mdrv_mhl_CheckCbusModeChange(ucBISTECbusMode);        if(ucBISTECbusMode == MHL_RAP_KEY_CBUS_MODE_UP)        {            mdrv_mhl_BISTModeUpProc();        }        else if(ucBISTECbusMode == MHL_RAP_KEY_CBUS_MODE_DOWN)        {            mdrv_mhl_BISTModeDownProc();        }    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_FeatureRequestStateProc()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_FeatureRequestStateProc(void){    switch(GET_MHL_FEATURE_REQ_STATE())    {        case MHL_CBUS_FEATURE_START:            SET_MHL_FEATURE_REQ_STATE(MHL_CBUS_FEATURE_SEND_3D_INFORMATION);            SET_MHL_SEND_3D_INFORMATION();            SET_MHL_SEND_3D_DTD();            SET_MHL_SEND_3D_VIC();            break;        case MHL_CBUS_FEATURE_SEND_3D_INFORMATION:            if(!GET_MHL_SEND_3D_INFORMATION())            {                SET_MHL_FEATURE_REQ_STATE(MHL_CBUS_FEATURE_SEND_HIGH_END_VIDEO);                SET_MHL_SEND_HIGH_END_VIDEO();                SET_MHL_SEND_HEV_VIC();                SET_MHL_SEND_HEV_DTDA();                SET_MHL_SEND_HEV_DTDB();            }            break;        case MHL_CBUS_FEATURE_SEND_HIGH_END_VIDEO:            if(!GET_MHL_SEND_HIGH_END_VIDEO())            {                SET_MHL_FEATURE_REQ_STATE(MHL_CBUS_FEATURE_SEND_AUDIO_DATA_TUNNEL);                SET_MHL_SEND_AUDIO_DATA_TUNNEL();            }            break;        case MHL_CBUS_FEATURE_SEND_AUDIO_DATA_TUNNEL:            if(!GET_MHL_SEND_AUDIO_DATA_TUNNEL())            {                SET_MHL_FEATURE_REQ_STATE(MHL_CBUS_FEATURE_SEND_EMSC_DATA_TUNNEL);                SET_MHL_SEND_EMSC_DATA_TUNNEL();            }            break;        case MHL_CBUS_FEATURE_SEND_EMSC_DATA_TUNNEL:            if(!GET_MHL_SEND_EMSC_DATA_TUNNEL())            {                if(GET_MHL_WRITE_BURST_STATE() == MHL_CBUS_WRITE_BURST_NONE)                {                    SET_MHL_FEATURE_REQ_STATE(MHL_CBUS_FEATURE_SEND_FEATURE_COMPLETE);                }            }            break;        case MHL_CBUS_FEATURE_SEND_FEATURE_COMPLETE:            if(_mapi_mhl_CbusWriteStatusOrSetInt(0x20, BIT(6), FALSE))            {                SET_MHL_FEATURE_REQ_STATE(MHL_CBUS_FEATURE_END);            }            break;        case MHL_CBUS_FEATURE_END:            SET_MHL_FEATURE_REQ_STATE(MHL_CBUS_FEATURE_NONE);            break;        default:            break;    };}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusTxHandler()//  [Description]//                  MHL Cbus handle send MSC message//  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_CbusTxHandler(void){    _mapi_mhl_TxQueueHandler();    _mapi_mhl_SendDisplayCommand();    _mapi_mhl_WriteBurstEventProc();    _mapi_mhl_SendWriteBurstInformation();    if(GET_MHL_ENABLE_CBUS_ENHANCE()) // For MHL 3.0    {        _mapi_mhl_CbusBISTStateProc();        _mapi_mhl_FeatureRequestStateProc();    }}//**************************************************************************//  [Function Name]://                  _mapi_mhl_CbusRxHandler()//  [Description]//                  MHL Cbus reply the received MSC message//  [Arguments]:////  [Return]:////**************************************************************************void _mapi_mhl_CbusRxHandler(void){    MS_U8 uctemp = 0;    if(GET_MHL_RECEIVE_MSC())    {        CLR_MHL_RECEIVE_MSC();        if(GET_MHL_TIME_OUT_FLAG())        {            _mapi_mhl_SetControlTimer(0);   // timeout reset.        }    }    if(GET_MHL_RECEIVE_ACK())    {        CLR_MHL_RECEIVE_ACK();        if(GET_MHL_QUEUE_STATE(MHL_CBUS_RX_QUEUE_INDEX) != CBUS_REQ_IDLE)        {            SET_MHL_QUEUE_STATE(MHL_CBUS_RX_QUEUE_INDEX, CBUS_REQ_IDLE);        }        else        {            SET_MHL_QUEUE_STATE(gMHLInfo.MhlCbusInfo.curIdx, CBUS_REQ_IDLE);        }        uctemp = _mapi_mhl_CBusGetQueueIndex(gMHLInfo.MhlCbusInfo.curIdx);        // Update current index to search index, but not Rx queue index        if(uctemp < MHL_CBUS_RX_QUEUE_INDEX)        {            gMHLInfo.MhlCbusInfo.curIdx = uctemp;        }        if(GET_MHL_RX_MSG_COMMAND() == 0xFF)        {            SET_MHL_RX_MSG_COMMAND(0);            SET_MHL_DEBOUNCE_TIMER(10);        }        _mapi_mhl_CbusLinkCheck();        SET_MHL_CBUS_STATE(CBUS_STATE_IDLE);    }    if(GET_MHL_RECEIVE_ABORT())    {        CLR_MHL_RECEIVE_ABORT();        _mapi_mhl_SetControlTimer(CBUS_ABORT_PADING_SECS);    }    if(GET_MHL_RECEIVE_MSG())    {        CLR_MHL_RECEIVE_MSG();        _mapi_mhl_CbusMSGCommandProc(GET_MHL_RX_MSG_COMMAND(), GET_MHL_RX_MSG_DATA());        SET_MHL_CBUS_STATE(CBUS_STATE_IDLE);    }    if(GET_MHL_RECEIVE_ERROR())    {        CLR_MHL_RECEIVE_ERROR();        _mapi_mhl_SetControlTimer(CBUS_ABORT_PADING_SECS);    }    if(GET_MHL_RECEIVE_DEVCAP()) // Receive devcap ready or change    {        if(!GET_MHL_READ_XDEVCAP_ENABLE())        {            CLR_MHL_RECEIVE_DEVCAP();            SET_MHL_READ_DEVCAP_ENABLE();        }    }    if(GET_MHL_RECEIVE_XDEVCAP()) // Receive extended device capability support    {        if(mdrv_mhl_GetEnhanceCbusFlag()) // Check chip support ECbus        {            if(!GET_MHL_READ_DEVCAP_ENABLE())            {                CLR_MHL_RECEIVE_XDEVCAP();                SET_MHL_READ_XDEVCAP_ENABLE();            }        }        else        {            CLR_MHL_RECEIVE_XDEVCAP();        }    }    if(GET_MHL_RECEIVE_MHL3_VERSION()) // Receive source support MHL3    {        CLR_MHL_RECEIVE_MHL3_VERSION();        if(mdrv_mhl_GetEnhanceCbusFlag()) // Check chip support ECbus        {            SET_MHL_ENABLE_CBUS_ENHANCE();        }    }    if(GET_MHL_RECEIVE_3D_REQUEST()) // Receive 3D request    {        if(GET_MHL_SEND_3D_INFORMATION())        {            CLR_MHL_RECEIVE_3D_REQUEST();        }        else if(GET_MHL_WRITE_BURST_STATE() == MHL_CBUS_WRITE_BURST_NONE)        {            CLR_MHL_RECEIVE_3D_REQUEST();            SET_MHL_SEND_3D_INFORMATION();            SET_MHL_SEND_3D_DTD();            SET_MHL_SEND_3D_VIC();        }    }    if(GET_MHL_RECEIVE_FEATURE_REQUEST()) // Receive feature request    {        CLR_MHL_RECEIVE_FEATURE_REQUEST();        if(GET_MHL_FEATURE_REQ_STATE() == MHL_CBUS_FEATURE_NONE)        {            SET_MHL_FEATURE_REQ_STATE(MHL_CBUS_FEATURE_START);        }    }    if(GET_MHL_RECEIVE_FEATURE_COMPLETE()) // Receive feature complete    {        CLR_MHL_RECEIVE_FEATURE_COMPLETE();        if(GET_MHL_FEATURE_REQ_STATE() == MHL_CBUS_FEATURE_SEND_FEATURE_REQUEST)        {            SET_MHL_FEATURE_REQ_STATE(MHL_CBUS_FEATURE_END);        }    }    if(GET_MHL_RECEIVE_LINK_RATE())    {        mdrv_mhl_SetMainLinkRate(GET_MHL_LINK_RATE());                CLR_MHL_RECEIVE_LINK_RATE();    }}//-------------------------------------------------------------------------------------------------//  Global Functions//-------------------------------------------------------------------------------------------------//**************************************************************************//  [Function Name]://                  mapi_mhl_RegisterCallBackFunctions()//  [Description]//                  RCP &RAP call back//  [Arguments]:////  [Return]:////**************************************************************************void mapi_mhl_RegisterCallBackFunctions(link_cbus_event_handle_func rcp, link_cbus_event_handle_func rap){    pfnMapi_mhl_CbusRcpProcess = rcp;    pfnMapi_mhl_CbusRapProcess = rap;}void mapi_mhl_RegisterRcpCallBackFunctions(link_cbus_event_handle_func rcp){    pfnMapi_mhl_CbusRcpProcess = rcp;}void mapi_mhl_RegisterRapCallBackFunctions(link_cbus_event_handle_func rap){    pfnMapi_mhl_CbusRapProcess = rap;}//**************************************************************************//  [Function Name]://                  mapi_mhl_RegisterUcpCallBackFunction()//  [Description]//                  UCP call back//  [Arguments]:////  [Return]:////**************************************************************************void mapi_mhl_RegisterUcpCallBackFunction(link_cbus_event_handle_func Ucp){    pfnMapi_mhl_CbusUcpProcess = Ucp;}//**************************************************************************//  [Function Name]://                  mapi_mhl_MHLSupportPath()//  [Description]//                  MHL support path//  [Arguments]:////  [Return]:////**************************************************************************void mapi_mhl_MHLSupportPath(MS_U8 ucSelect){    mdrv_mhl_MHLSupportPath(ucSelect);}//**************************************************************************//  [Function Name]://                  mapi_mhl_Init()//  [Description]//                  MHL init//  [Arguments]:////  [Return]:////**************************************************************************void mapi_mhl_init(MS_U8 *edid, MS_U8 *DevCap){    static MS_BOOL bIsrAttachFlag = FALSE;    MS_BOOL uctemp = 0;    memset(&gMHLInfo, 0, sizeof(gMHLInfo));    mdrv_mhl_initial(edid, DevCap);    mdrv_mhl_ParsingEDIDfor3D(edid);    if(mdrv_mhl_CbusInitialProc())    {        _mapi_mhl_CbusStatusConstruct(TRUE);        mdrv_mhl_CbusConfigControl(TRUE);    }    _mapi_mhl_SetPowerOnTimer(20);    SET_MHL_PORT_SELECT(mdrv_mhl_GetInputPort());    msg_mhl(printf("mapi_mhl_init()\r\n"));    if(!bIsrAttachFlag)    {        if(mdrv_mhl_CheckIsrUsePMPath())        {            MsOS_AttachInterrupt(E_INT_IRQ_PM, _mapi_mhl_IsrHandler);            MsOS_EnableInterrupt(E_INT_IRQ_PM);            bIsrAttachFlag = TRUE;        }        else        {            MsOS_AttachInterrupt(E_INT_IRQ_MHL_CBUS_PM, _mapi_mhl_IsrHandler);            //MsOS_DisableInterrupt(E_INT_IRQ_MHL_CBUS_PM);            MsOS_EnableInterrupt(E_INT_IRQ_MHL_CBUS_PM);            bIsrAttachFlag = TRUE;        }        if(mdrv_mhl_GetEnhanceCbusFlag())        {            MsOS_AttachInterrupt(E_INT_IRQ_MHL_ECBUS_INT, _mapi_mhl_ECbusIsrHandler);            MsOS_EnableInterrupt(E_INT_IRQ_MHL_ECBUS_INT);        }    }    mapi_mhl_GetDeviceVenderID(&uctemp);}//**************************************************************************//  [Function Name]://                  mapi_mhl_LoadEDID()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mapi_mhl_LoadEDID(MS_U8 *edid){    mdrv_mhl_LoadEDID(edid);    mdrv_mhl_ParsingEDIDfor3D(edid);}//**************************************************************************//  [Function Name]://                  mapi_mhl_ReadEDID()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mapi_mhl_ReadEDID(MS_U16 usSize, MS_U8 *edid){	mdrv_mhl_ReadEDID(usSize, edid);}//**************************************************************************//  [Function Name]://                  mapi_mhl_LoadDeviceCapability()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mapi_mhl_LoadDeviceCapability(MS_U8 *devcap){    mdrv_mhl_LoadDeviceCapability(devcap);}//**************************************************************************//  [Function Name]://                  mapi_mhl_SetVenderID()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mapi_mhl_SetVenderID(MS_U8 ucVenderID){    mdrv_mhl_SetVenderID(ucVenderID);}//**************************************************************************//  [Function Name]://                  mapi_mhl_InvertCableDetect()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mapi_mhl_InvertCableDetect(MS_BOOL bCableDetectInvert){    mdrv_mhl_InvertCableDetect(bCableDetectInvert);}//**************************************************************************//  [Function Name]://                  mapi_mhl_VbusConfigSetting()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mapi_mhl_VbusConfigSetting(MS_U8 ucState){    mdrv_mhl_VbusConfigSetting(ucState);}//**************************************************************************//  [Function Name]://                  mapi_mhl_CableDetectPadSetting()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mapi_mhl_CableDetectPadSetting(MS_U8 ucSelect){    mdrv_mhl_CableDetectPadSetting(ucSelect);}//**************************************************************************//  [Function Name]://                  mapi_mhl_handler()//  [Description]//                  MHL handler//  [Arguments]:////  [Return]:////**************************************************************************void mapi_mhl_handler(void){    MS_U32 ulTimer = MsOS_GetSystemTime();    _mapi_mhl_CbusTimerHandler(ulTimer);    if((!_mapi_mhl_CbusStatusConstruct(FALSE)) && _mapi_mhl_CableDetect(mdrv_mhl_GetInputPort()))    {        if(GET_MHL_CBUS_CONNECT())        {#if(MHL_CBUS_OPERATION_MODE == MHL_CBUS_SW_POLLING_MODE)            _mapi_mhl_CbusIntCB();            _mapi_mhl_CbusIntHandler();#elif(MHL_CBUS_OPERATION_MODE == MHL_CBUS_HW_REPLY_MODE)            _mapi_mhl_CbusIntCB();#endif            _mapi_mhl_CbusRxHandler();        }        if(_mapi_mhl_CbusStatus())        {            _mapi_mhl_CbusTxHandler();        }        _mapi_mhl_CbusConnectionCheck();    }}//**************************************************************************//  [Function Name]://                  mapi_mhl_PowerCtrl()//  [Description]//                  Control R-term power//  [Arguments]:////  [Return]:////**************************************************************************void mapi_mhl_PowerCtrl(E_MHL_POWERCTRL_Mode pctrl){    SET_MHL_POWER_STATUS(pctrl);    switch(pctrl)    {        case E_MHL_POWER_ON:            msg_mhl(printf("MHL power on mode\r\n"));            mdrv_mhl_PowerOn();            break;        case E_MHL_POWER_STANDBY:            msg_mhl(printf("MHL power standby mode\r\n"));            memset(&(gMHLInfo.MhlCbusInfo), 0, sizeof(gMHLInfo.MhlCbusInfo));            mdrv_mhl_PowerStandby(GET_MHL_CABLE_PLUGGED());            break;        case E_MHL_POWER_DOWN:            msg_mhl(printf("MHL power down mode\r\n"));            memset(&(gMHLInfo.MhlCbusInfo), 0, sizeof(gMHLInfo.MhlCbusInfo));            mdrv_mhl_PowerDown();            break;        default:            msg_mhl(printf("Wrong MHL power mode\r\n"));            break;    }}//**************************************************************************//  [Function Name]://                  mapi_mhl_CableDetect()//  [Description]//                  Get MHL cable detection flag//  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mapi_mhl_CableDetect(void){    return GET_MHL_CABLE_PLUGGED();}//**************************************************************************//  [Function Name]://                  mapi_mhl_CbusStatus()//  [Description]//                  Get MHL CBUS connetion flag//  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mapi_mhl_CbusStatus(void){    return GET_MHL_CBUS_CONNECT();}//**************************************************************************//  [Function Name]://                  mapi_mhl_ReadDevcapFlag()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mapi_mhl_ReadDevcapFlag(void){    return GET_MHL_RECEIVE_DEVCAP();}//**************************************************************************//  [Function Name]://                  mapi_mhl_SrcRCPSupportFlag()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mapi_mhl_SrcRCPSupportFlag(void){    return GET_MHL_SEND_RCP_ENABLE();}//**************************************************************************//  [Function Name]://                  mapi_mhl_SrcRAPSupportFlag()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mapi_mhl_SrcRAPSupportFlag(void){    return GET_MHL_SEND_RAP_ENABLE();}//**************************************************************************//  [Function Name]://                  mapi_mhl_SrcMSGResponseFlag()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mapi_mhl_SrcMSGResponseFlag(void){    MS_BOOL bindex = FALSE;    if(GET_MHL_SEND_MSG_FINISH())    {        CLR_MHL_SEND_MSG_FINISH();        bindex = TRUE;    }    return bindex;}//**************************************************************************//  [Function Name]://                  mapi_mhl_SendMSGCmdFlag//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mapi_mhl_SendMSGCmdFlag(void){    MS_BOOL bFlag = FALSE;    if((!GET_MHL_SEND_CLR_HPD()) && GET_MHL_CBUS_CONNECT() &&mdrv_mhl_CheckInputPort())    {        bFlag = TRUE;    }    return bFlag;}//**************************************************************************//  [Function Name]://                  mapi_mhl_SendRAPCmd//  [Description]//                  MHL Cbus MSC Send RAP Command//  [Arguments]:////  [Return]://                  TRUE: success//                  FALSE: fail//**************************************************************************MS_BOOL mapi_mhl_SendRAPCmd(MS_U8 databuf){    return _mapi_mhl_CbusMscMsgSubCmdSend(MSC_MSG_RAP, databuf, TRUE);}//**************************************************************************//  [Function Name]://                  mapi_mhl_SendRCPCmd//  [Description]//                  MHL Cbus MSC Send RCP Command//  [Arguments]:////  [Return]://                  TRUE: success//                  FALSE: fail//**************************************************************************MS_BOOL mapi_mhl_SendRCPCmd(MS_U8 databuf){    return _mapi_mhl_CbusMscMsgSubCmdSend(MSC_MSG_RCP, databuf, TRUE);}//**************************************************************************//  [Function Name]://                  mapi_mhl_SendRCP_PressRelease_Cmd//  [Description]////  [Arguments]:////  [Return]://                  TRUE: success//                  FALSE: fail//**************************************************************************MS_BOOL mapi_mhl_SendRCP_PressRelease_Cmd(MS_U8 u8RCPKey, MS_BOOL bIsRelease){    //bIsRelease    //0: press    //1: release    return mapi_mhl_SendRCPCmd((u8RCPKey|(bIsRelease<<7)));}//**************************************************************************//  [Function Name]://                  mapi_mhl_SendRCPAutoReleaseCmd//  [Description]//                  MHL Cbus MSC Send RCP Command//  [Arguments]:////  [Return]://                  TRUE: success//                  FALSE: fail//**************************************************************************MS_BOOL mapi_mhl_SendRCPAutoReleaseCmd(MS_U8 ucKeyCode){    MS_BOOL bSendRCP = FALSE;    if(_mapi_mhl_CbusMscMsgSubCmdSend(MSC_MSG_RCP, ucKeyCode, TRUE))    {        bSendRCP = TRUE;        _mapi_mhl_SetRCPReleaseSendTime(CBUS_MSG_RCP_RELEASE_INTERVAL, ucKeyCode);        msg_mhl(printf("** MHL send RCP press key code 0x%x port %c\r\n", ucKeyCode, MHL_INPUT_PORT(mdrv_mhl_GetCbusPath())));    }    return bSendRCP;}//**************************************************************************//  [Function Name]://                  mapi_mhl_SendUCPCmd//  [Description]//                  MHL Cbus MSC Send UCP Command//  [Arguments]:////  [Return]://                  TRUE: success//                  FALSE: fail//**************************************************************************MS_BOOL mapi_mhl_SendUCPCmd(MS_U8 databuf){    return _mapi_mhl_CbusMscMsgSubCmdSend(MSC_MSG_UCP, databuf, TRUE);}//**************************************************************************//  [Function Name]://                  mapi_mhl_SendWriteBurst//  [Description]////  [Arguments]:////  [Return]://                  TRUE: success//                  FALSE: fail//**************************************************************************MS_BOOL mapi_mhl_SendWriteBurst(MS_U8 ucAddr, MS_U8 ucLength, MS_U8 *buffer){    MS_U8 uctemp = 0;    CbusReq_S req;    req.cmd = MSC_WRITE_BURST;    req.msgData[0] = ucAddr;    for(uctemp = 0;uctemp <ucLength;uctemp++)    {        req.msgData[uctemp +1] = buffer[uctemp];    }    req.len = ucLength +1; // offset + data packets    req.reqStatus = CBUS_REQ_PENDING;    return (_mapi_mhl_CbusQueueMscTxRequest(gMHLInfo.MhlCbusInfo.curIdx, &req));}//**************************************************************************//  [Function Name]://                  mapi_mhl_ReadDeviceCapacibility//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mapi_mhl_ReadDeviceCapacibility(MS_U8 ucAddr, MS_U8 *ucData){    MS_BOOL bindex = FALSE;    return bindex;}//**************************************************************************//  [Function Name]://                  mapi_mhl_GetDeviceCapacibility//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mapi_mhl_GetDeviceCapacibility(MS_U16 usDevcapMask, MS_U8 *ucDevcap){    static MS_U16 usDevCap = 0;    MS_BOOL bindex = FALSE;    MS_BOOL bFinish = FALSE;    MS_U8 uctemp = 0;    MS_U8 ucData = 0;    if(GET_MHL_READ_DEVCAP_ENABLE())    {        do        {            if(usDevCap &usDevcapMask)            {                uctemp = _mapi_mhl_GetLeastBitNum(usDevCap);                bindex = _mapi_mhl_CbusReadDeviceCapacibility(uctemp, &ucData, GET_MHL_SEND_READ_DEVCAP(), FALSE);                if(bindex)                {                    CLR_MHL_SEND_READ_DEVCAP();                    usDevCap = MASKSET(usDevCap, 0, BIT(uctemp));                    *(ucDevcap +uctemp) = ucData;                    if(uctemp == MHL_CBUS_FEATURE_FLAG)                    {                        if(ucData &BIT(0))                        {                            SET_MHL_SEND_RCP_ENABLE();                        }                        if(ucData &BIT(1))                        {                            SET_MHL_SEND_RAP_ENABLE();                        }                    }                    if(usDevCap == 0)                    {                        bFinish = TRUE;                        CLR_MHL_READ_DEVCAP_ENABLE();#if(DMHL_AUTO_SENT_RAP_POLLING)                        if(GET_MHL_SEND_RAP_ENABLE())                        {                            mapi_mhl_SendRAPCmd(MSC_RAP_POLL);                        }#endif                        _mapi_mhl_CheckDeviceCapacibility(ucDevcap);                    }                }            }            else            {                bindex = FALSE;            }        }while(bindex);    }    else    {        usDevCap = usDevcapMask;    }    return bFinish;}//**************************************************************************//  [Function Name]://                  mapi_mhl_GetExtendDeviceCapacibility//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mapi_mhl_GetExtendDeviceCapacibility(MS_U16 usExtendDevcapMask, MS_U8 *ucExtendDevcap){    static MS_U16 usExtendDevCap = 0;    MS_BOOL bindex = FALSE;    MS_BOOL bFinish = FALSE;    MS_U8 uctemp = 0;    MS_U8 ucData = 0;    if(GET_MHL_READ_XDEVCAP_ENABLE())    {        do        {            if(usExtendDevCap &usExtendDevcapMask)            {                uctemp = _mapi_mhl_GetLeastBitNum(usExtendDevCap);                bindex = _mapi_mhl_CbusReadDeviceCapacibility(uctemp, &ucData, GET_MHL_SEND_READ_DEVCAP(), TRUE);                if(bindex)                {                    CLR_MHL_SEND_READ_DEVCAP();                    usExtendDevCap = MASKSET(usExtendDevCap, 0, BIT(uctemp));                    *(ucExtendDevcap +uctemp) = ucData;                    if(usExtendDevCap == 0)                    {                        bFinish = TRUE;                        CLR_MHL_READ_XDEVCAP_ENABLE();                    }                }            }            else            {                bindex = FALSE;            }        }while(bindex);    }    else    {        usExtendDevCap = usExtendDevcapMask;    }    return bFinish;}//**************************************************************************//  [Function Name]://                  mapi_mhl_GetDeviceVenderID//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mapi_mhl_GetDeviceVenderID(MS_U8 *ucVenderID){    static MS_BOOL bVenderID = FALSE;    MS_BOOL bindex = FALSE;    MS_BOOL bFinish = FALSE;    MS_U8 ucData = 0;    if(GET_MHL_GET_VENDER_ID_ENABLE())    {        if(bVenderID)        {            bindex = _mapi_mhl_CbusReadVenderID(&ucData, GET_MHL_SEND_GET_VENDER_ID());            if(bindex)            {                CLR_MHL_SEND_GET_VENDER_ID();                CLR_MHL_GET_VENDER_ID_ENABLE();                *ucVenderID = ucData;                bVenderID = FALSE;                bFinish = TRUE;            }        }    }    else    {        bVenderID = TRUE;    }    return bFinish;}//**************************************************************************//  [Function Name]://                  mapi_mhl_GetWriteBurstData//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mapi_mhl_GetWriteBurstData(MS_U8 *ucData){    MS_BOOL bFlag = FALSE;    MS_U8 uctemp = 0;    if(GET_MHL_WRITE_BURST_ADDRESS() > 0)    {        SET_MHL_WRITE_BURST_ADDRESS(0);        for(uctemp = 0; uctemp < GET_MHL_WRITE_BURST_LENGTH(); uctemp++)        {            ucData[uctemp] = GET_MHL_WRITE_BURST_DATA(uctemp);        }        bFlag = TRUE;    }    return bFlag;}//**************************************************************************//  [Function Name]://                  mapi_mhl_Send3DInformation()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mapi_mhl_Send3DInformation(void){    // Remove}#if(DMHL_CTS_SEND_MSC)//**************************************************************************//  [Function Name]://                  mapi_mhl_CbusSendCommand()//  [Description]//                  For CTS send a MSC command//  [Arguments]:////  [Return]:////**************************************************************************void mapi_mhl_CbusSendCommand(void){    _mapi_mhl_CbusSendDevcapChange(TRUE);}#endif//**************************************************************************//  [Function Name]://                  mapi_mhl_CbusIsolate//  [Description]//                  MHL Cbus isolate//  [Arguments]:////  [Return]:////**************************************************************************void mapi_mhl_CbusIsolate(void){    CLR_MHL_PORT_ON_FLAG();    mdrv_mhl_CbusIsolate(TRUE);    _mapi_mhl_SetControlTimer(0);}#if(DMHL_WAKE_UP_PULSE_INT)//**************************************************************************//  [Function Name]://                  mapi_mhl_CbusWakeupIntSetting()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mapi_mhl_CbusWakeupIntSetting(void){    mdrv_mhl_CbusWakeupIntSetting(TRUE);}//**************************************************************************//  [Function Name]://                  mapi_mhl_CbusWakeupIntFlag()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mapi_mhl_CbusWakeupIntFlag(void){    MS_BOOL bindex = (GET_MHL_RECEIVE_WAKE() || mdrv_mhl_CbusWakeupIntFlag());    if(bindex)    {        CLR_MHL_RECEIVE_WAKE();    }    return bindex;}//**************************************************************************//  [Function Name]://                  mapi_mhl_AutoSwitchHandler()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mapi_mhl_AutoSwitchHandler(MS_BOOL bReset, MS_U8 *ucCbusPath){    static MS_BOOL bWakeSetting = FALSE;    static MS_BOOL bHWRtermControl = FALSE;    MS_BOOL bAutoSwitch = FALSE;    MS_BOOL bWakeUp = mapi_mhl_CbusWakeupIntFlag() &bWakeSetting;    static MS_U16 usWaitSwitchSourceCount = 0;    if(bReset)    {        bWakeSetting = FALSE;        bWakeUp = FALSE;        mdrv_mhl_CbusControl(MHL_VBUS_HW_DETCET);        mdrv_mhl_CbusWakeupIntSetting(FALSE);    }    else if(bWakeSetting && bWakeUp)    {        bWakeSetting = FALSE;        *ucCbusPath = mdrv_mhl_GetCbusPath();        mdrv_mhl_RtermControlHWMode(TRUE);        bHWRtermControl = TRUE;        msg_mhl(printf("** MHL Auto switch to port %c\r\n", MHL_INPUT_PORT(*ucCbusPath)));        bAutoSwitch = TRUE;        usWaitSwitchSourceCount = 1000;    }    else if(!GET_MHL_CBUS_CONNECT())    {        if(bWakeSetting)        {            if(!bWakeUp)            {                if(GET_MHL_CABLE_PLUGGED())                {                    mdrv_mhl_CbusControl(MHL_VBUS_CHARGE_ON);                }                else                {                    mdrv_mhl_CbusControl(MHL_VBUS_HW_DETCET);                }                if(mdrv_mhl_CheckInputPort() && (!GET_MHL_SEND_CLR_HPD()))                {                    mdrv_mhl_CbusWakeupIntSetting(FALSE);                    bWakeSetting = FALSE;                }            }        }        else if((!mdrv_mhl_CheckInputPort()) || GET_MHL_SEND_CLR_HPD())        {            if(usWaitSwitchSourceCount == 0)            {                mdrv_mhl_CbusWakeupIntSetting(TRUE);                bWakeSetting = TRUE;            }        }    }    else if(usWaitSwitchSourceCount > 0)    {        if(GET_MHL_CBUS_CONNECT())        {            usWaitSwitchSourceCount = 0;        }        else        {            usWaitSwitchSourceCount--;        }    }    if(bHWRtermControl && (!bWakeUp) && (!bReset))    {        mdrv_mhl_RtermControlHWMode(FALSE);        bHWRtermControl = FALSE;    }    return bAutoSwitch;}#endif//**************************************************************************//  [Function Name]://                  mapi_mhl_AdjustSettingIControl()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mapi_mhl_AdjustSettingIControl(MS_U8 ucIControl){    mdrv_mhl_AdjustSettingIControl(ucIControl);}//**************************************************************************//  [Function Name]://                  mapi_mhl_AdjustImpedanceSetting()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mapi_mhl_AdjustImpedanceSetting(MS_U8 ucImpedance){    mdrv_mhl_AdjustImpedanceSetting(ucImpedance);}//**************************************************************************//  [Function Name]://                  mapi_mhl_SetPowerState()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_U32 mapi_mhl_SetPowerState(EN_POWER_MODE usPowerState){    static EN_POWER_MODE usPrePowerState = E_POWER_MECHANICAL;    MS_U32 ulFailFlag = 1;    if(usPowerState != usPrePowerState)    {        usPrePowerState = usPowerState;        if(usPowerState == E_POWER_SUSPEND)        {            _mapi_mhl_ForceClearHPD();                        ulFailFlag = 0;        }        else if(usPowerState == E_POWER_RESUME)        {            mdrv_mhl_initial(NULL, NULL);            mdrv_mhl_PowerResume(GET_MHL_CABLE_PLUGGED(), GET_MHL_CBUS_CONNECT());            ulFailFlag = 0;        }    }    return ulFailFlag;}//**************************************************************************//  [Function Name]://                  mapi_mhl_WakeupDetect()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mapi_mhl_WakeupDetect(void){    return FALSE;}//**************************************************************************//  [Function Name]://                  mapi_mhl_SetHPD()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mapi_mhl_SetHPD(MS_BOOL bflag){    if(GET_MHL_CABLE_PLUGGED() == FALSE)    {        mdrv_mhl_SetHPD(bflag);    }}//**************************************************************************//  [Function Name]://                  mapi_mhl_SetPsCtrl()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mapi_mhl_SetPsCtrl(MS_U8 u8Ctrl){}//**************************************************************************//  [Function Name]://                  mapi_mhl_CbusControl()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************void mapi_mhl_CbusControl(MS_U8 ucState){    switch(ucState)    {        case MHL_CBUS_FORCE_CLEAR_HPD:            if(!GET_MHL_SEND_CLR_HPD())            {                SET_MHL_SEND_CLR_HPD();                if(GET_MHL_HPD_SET_FLAG())                {                    _mapi_mhl_ForceClearHPD();                }            }            break;        case MHL_CBUS_FORCE_RESET_HPD:            if(GET_MHL_SEND_CLR_HPD())            {                CLR_MHL_SEND_CLR_HPD();            }            break;        case MHL_CBUS_FORCE_READY_DEVCAP:            SET_MHL_RECEIVE_DEVCAP();            break;        case MHL_CBUS_FORCE_RECEIVE_3D_REQ:            SET_MHL_RECEIVE_3D_REQUEST();            break;        case MHL_CBUS_FORCE_SEND_COMMAND_ENABLE:            SET_MHL_FORCE_SEND_COMMAND();            break;        case MHL_CBUS_FORCE_SEND_COMMAND_DISABLE:            CLR_MHL_FORCE_SEND_COMMAND();            break;        case MHL_CBUS_CHECK_CONTEND_ON_ENABLE:            SET_MHL_CHECK_CONTENT_ENABLE();            break;        case MHL_CBUS_CHECK_CONTEND_ON_DISABLE:            CLR_MHL_CHECK_CONTENT_ENABLE();            break;        default:            mdrv_mhl_CbusControl(ucState);            break;    };}//**************************************************************************//  [Function Name]://                  mapi_mhl_CbusGetStatusFlag()//  [Description]////  [Arguments]:////  [Return]:////**************************************************************************MS_BOOL mapi_mhl_CbusGetStatusFlag(MS_U8 ucState){    MS_BOOL bFlag = FALSE;    switch(ucState)    {        case MHL_CBUS_STATUS_FLAG_CABLE_DETECT:            bFlag = GET_MHL_CABLE_PLUGGED();            break;        case MHL_CBUS_STATUS_FLAG_CBUS_CONNECT:            bFlag = GET_MHL_CBUS_CONNECT();            break;        case MHL_CBUS_STATUS_FLAG_PATH_EN:            bFlag = GET_MHL_PATH_EN_FLAG();            break;        case MHL_CBUS_STATUS_FLAG_RECEIVE_PATH_EN:            bFlag = GET_MHL_RECEIVE_PATH_EN();            break;        case MHL_CBUS_STATUS_FLAG_RECEIVE_MUTED:            bFlag = GET_MHL_RECEIVE_MUTED();            break;        default:            break;    };    return bFlag;}void mapi_mhl_GetSWVersion(void){    char str[20] = "MHL-";    strncat(str, FW_VER_MAJOR, 2);    strncat(str, ".", 1);    strncat(str, FW_VER_MINOR, 2);    strncat(str, ".",1);    strncat(str, P4_CHANGELIST, 8);    printf("The SW Version of MHL is %s\n", str);}char* mapi_mhl_GetP4CL(void){    return P4_CHANGELIST;}char* mapi_mhl_GetMajorVersion(void){    return FW_VER_MAJOR;}char* mapi_mhl_GetMinorVersion(void){    return FW_VER_MINOR;}#endif // _MAPI_MHL_C_